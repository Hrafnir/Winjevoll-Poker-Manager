// === 01: DOMContentLoaded LISTENER START ===
document.addEventListener('DOMContentLoaded', async () => {
    console.log("Tournament page DOM loaded.");
    // === 02: STATE VARIABLES START ===
    let currentTournamentId = getActiveTournamentId();
    let state = null; let timerInterval = null; let realTimeInterval = null; let isModalOpen = false; let currentOpenModal = null;
    let originalThemeBg = '', originalThemeText = '', originalElementLayouts = {}, originalSoundVolume = 0.7;
    let currentLogoBlob = null, logoBlobInModal = null, currentLogoObjectUrl = null, previewLogoObjectUrl = null;
    let blockSliderUpdates = false; let isDragging = false, draggedElement = null, offsetX = 0, offsetY = 0;
    let soundsEnabled = loadSoundPreference(); let currentVolume = loadSoundVolume(); const SOUND_URLS = { NEW_LEVEL: 'sounds/new_level.wav', PAUSE_START: 'sounds/pause_start.wav', PAUSE_END: 'sounds/pause_end.wav', BUBBLE: 'sounds/bubble_start.wav', KNOCKOUT: 'sounds/knockout.wav', FINAL_TABLE: 'sounds/final_table.wav', TOURNAMENT_END: 'sounds/tournament_end.wav', TEST: 'sounds/new_level.wav' };
    const PREDEFINED_THEMES = [ { name: "Elegant & Moderne", bg: "rgb(28, 28, 30)", text: "rgb(245, 245, 245)" }, { name: "Lys & Frisk", bg: "rgb(232, 245, 252)", text: "rgb(33, 53, 71)" }, { name: "Retro & Kreativ", bg: "rgb(255, 235, 148)", text: "rgb(43, 43, 43)" }, { name: "Dramatisk & Stilren", bg: "rgb(34, 0, 51)", text: "rgb(255, 255, 255)" }, { name: "Naturell & Harmonisk", bg: "rgb(223, 228, 212)", text: "rgb(61, 64, 54)" }, ];
    let editBlindLevelCounter = 0; const standardPayouts = { 1: [100], 2: [65, 35], 3: [50, 30, 20], 4: [45, 27, 18, 10], 5: [40, 25, 16, 11, 8], 6: [38, 24, 15, 10, 8, 5], 7: [36, 23, 14, 10, 8, 5, 4], 8: [35, 22, 13, 9, 7, 6, 4, 4], 9: [34, 21, 13, 9, 7, 6, 4, 3, 3], 10: [33, 20, 12, 9, 7, 6, 5, 3, 3, 2] };
    // === 02: STATE VARIABLES END ===

    // === 03: DOM REFERENCES START ===
    // Hoved-UI og generelle elementer (OK √• hente her)
    const currentTimeDisplay = document.getElementById('current-time'); const btnToggleSound = document.getElementById('btn-toggle-sound'); const btnEditTournamentSettings = document.getElementById('btn-edit-tournament-settings'); const btnEditUiSettings = document.getElementById('btn-edit-ui-settings'); const btnBackToMainLive = document.getElementById('btn-back-to-main-live'); const prizeDisplayLive = document.getElementById('prize-display-live'); const totalPotPrizeSpan = document.getElementById('total-pot'); const startPauseButton = document.getElementById('btn-start-pause'); const prevLevelButton = document.getElementById('btn-prev-level'); const nextLevelButton = document.getElementById('btn-next-level'); const adjustTimeMinusButton = document.getElementById('btn-adjust-time-minus'); const adjustTimePlusButton = document.getElementById('btn-adjust-time-plus'); const lateRegButton = document.getElementById('btn-late-reg'); const playerListUl = document.getElementById('player-list'); const eliminatedPlayerListUl = document.getElementById('eliminated-player-list'); const activePlayerCountSpan = document.getElementById('active-player-count'); const eliminatedPlayerCountSpan = document.getElementById('eliminated-player-count'); const tableBalanceInfo = document.getElementById('table-balance-info'); const btnForceSave = document.getElementById('btn-force-save'); const endTournamentButton = document.getElementById('btn-end-tournament'); const activityLogUl = document.getElementById('activity-log-list'); const headerRightControls = document.querySelector('.header-right-controls'); const liveCanvas = document.getElementById('live-canvas'); const titleElement = document.getElementById('title-element'); const timerElement = document.getElementById('timer-element'); const blindsElement = document.getElementById('blinds-element'); const logoElement = document.getElementById('logo-element'); const infoElement = document.getElementById('info-element'); const draggableElements = [titleElement, timerElement, blindsElement, logoElement, infoElement]; const nameDisplay = document.getElementById('tournament-name-display'); const timerDisplay = document.getElementById('timer-display'); const breakInfo = document.getElementById('break-info'); const currentLevelDisplay = document.getElementById('current-level'); const blindsDisplay = document.getElementById('blinds-display'); const logoImg = logoElement?.querySelector('.logo'); const nextBlindsDisplay = document.getElementById('next-blinds'); const infoNextPauseParagraph = document.getElementById('info-next-pause'); const averageStackDisplay = document.getElementById('average-stack'); const playersRemainingDisplay = document.getElementById('players-remaining'); const totalEntriesDisplay = document.getElementById('total-entries'); const lateRegStatusDisplay = document.getElementById('late-reg-status');
    // Modal containere (OK √• hente her)
    const tournamentSettingsModal = document.getElementById('tournament-settings-modal'); const uiSettingsModal = document.getElementById('ui-settings-modal'); const addonModal = document.getElementById('addon-modal'); const editPlayerModal = document.getElementById('edit-player-modal');
    // KNAPPER for √• √•pne modaler (OK √• hente her)
    const btnManageAddons = document.getElementById('btn-manage-addons');

    // Referanser til elementer INNE i modaler hentes n√• i open...Modal funksjonene
    // === 03: DOM REFERENCES END ===

    // === 04: INITIALIZATION & VALIDATION START ===
    if (!currentTournamentId) { alert("Ingen aktiv turnering valgt."); window.location.href = 'index.html'; return; }
    state = loadTournamentState(currentTournamentId);
    if (!state || !state.config || !state.live || !state.config.blindLevels || state.config.blindLevels.length === 0) { alert(`Kunne ikke laste gyldig turneringsdata (ID: ${currentTournamentId}).`); console.error("Invalid tournament state loaded:", state); clearActiveTournamentId(); window.location.href = 'index.html'; return; }
    state.live = state.live || {}; state.live.status = state.live.status || 'paused'; state.live.currentLevelIndex = state.live.currentLevelIndex ?? 0; state.live.timeRemainingInLevel = state.live.timeRemainingInLevel ?? (state.config.blindLevels[state.live.currentLevelIndex]?.duration * 60 || 1200); state.live.isOnBreak = state.live.isOnBreak ?? false; state.live.timeRemainingInBreak = state.live.timeRemainingInBreak ?? 0; state.live.players = state.live.players || []; state.live.eliminatedPlayers = state.live.eliminatedPlayers || []; state.live.knockoutLog = state.live.knockoutLog || []; state.live.activityLog = state.live.activityLog || []; state.live.totalPot = state.live.totalPot ?? 0; state.live.totalEntries = state.live.totalEntries ?? 0; state.live.totalRebuys = state.live.totalRebuys ?? 0; state.live.totalAddons = state.live.totalAddons ?? 0;
    state.live.nextPlayerId = state.live.nextPlayerId || (Math.max(0, ...state.live.players.map(p => p.id), ...state.live.eliminatedPlayers.map(p => p.id)) + 1);
    console.log(`Loaded Tournament: ${state.config.name} (ID: ${currentTournamentId})`, state);
    // === 04: INITIALIZATION & VALIDATION END ===

    // === 04b: THEME & LAYOUT APPLICATION START ===
    function revokeObjectUrl(url) { if (url && url.startsWith('blob:')) { try { URL.revokeObjectURL(url); } catch (e) { console.warn("Error revoking Object URL:", url, e); } } }
    function updateImageSrc(logoBlob, targetImgElement, isPreview = false) { if (!targetImgElement) { console.warn("updateImageSrc called with no targetImgElement"); return; } const currentObjectUrlRef = isPreview ? previewLogoObjectUrl : currentLogoObjectUrl; revokeObjectUrl(currentObjectUrlRef); let newObjectUrl = null; if (logoBlob instanceof Blob && logoBlob.size > 0) { try { newObjectUrl = URL.createObjectURL(logoBlob); targetImgElement.src = newObjectUrl; targetImgElement.alt = "Egendefinert Logo"; } catch (e) { console.error("Error creating object URL:", e); targetImgElement.src = 'placeholder-logo.png'; targetImgElement.alt = "Feil ved lasting"; } } else { targetImgElement.src = 'placeholder-logo.png'; targetImgElement.alt = isPreview ? "Logo Forh√•ndsvisning" : "Winjevoll Pokerklubb Logo"; } if (isPreview) { previewLogoObjectUrl = newObjectUrl; } else { currentLogoObjectUrl = newObjectUrl; } }
    function setGlobalLogoState(logoBlob) { currentLogoBlob = logoBlob; updateImageSrc(logoBlob, logoImg, false); }
    async function applyThemeLayoutAndLogo() { console.log("applyThemeLayoutAndLogo: Starting initial load..."); const bgColor = loadThemeBgColor(); const textColor = loadThemeTextColor(); const elementLayouts = loadElementLayouts(); let logoDataBlob = null; try { logoDataBlob = await loadLogoBlob(); } catch (err) { console.error("Error loading logo blob initially:", err); } console.log("applyThemeLayoutAndLogo: Fetched initial data. Logo Blob:", logoDataBlob); applyThemeAndLayout(bgColor, textColor, elementLayouts); setGlobalLogoState(logoDataBlob); console.log("applyThemeLayoutAndLogo: Initial theme, layout, and logo applied."); }
    function applyThemeAndLayout(bgColor, textColor, elementLayouts) { console.log("Applying theme and layout:", bgColor, textColor, elementLayouts); const rootStyle = document.documentElement.style; rootStyle.setProperty('--live-page-bg', bgColor); rootStyle.setProperty('--live-page-text', textColor); try { const [r, g, b] = parseRgbString(bgColor); const brightness = (r * 299 + g * 587 + b * 114) / 1000; const borderColor = brightness < 128 ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)'; rootStyle.setProperty('--live-ui-border', borderColor); } catch (e) { rootStyle.setProperty('--live-ui-border', 'rgba(128, 128, 128, 0.15)'); } const defaults = DEFAULT_ELEMENT_LAYOUTS; rootStyle.setProperty('--canvas-height', `${elementLayouts.canvas?.height ?? defaults.canvas.height}vh`); draggableElements.forEach(element => { if (!element) return; const elementId = element.id.replace('-element', ''); const layout = { ...defaults[elementId], ...(elementLayouts[elementId] || {}) }; element.classList.toggle('element-hidden', !(layout.isVisible ?? true)); if (layout.isVisible ?? true) { element.style.left = `${layout.x}%`; element.style.top = `${layout.y}%`; element.style.width = `${layout.width}%`; if (elementId === 'logo') { element.style.height = `${layout.height}%`; element.style.fontSize = '1em'; } else { element.style.fontSize = `${layout.fontSize}em`; element.style.height = 'auto'; } } }); const infoLayout = { ...defaults.info, ...(elementLayouts.info || {}) }; for (const key in infoParagraphs) { if (infoParagraphs[key]) infoParagraphs[key].classList.toggle('hidden', !(infoLayout[key] ?? true)); } console.log("Theme and layout styles applied."); }
    try { await applyThemeLayoutAndLogo(); } catch (err) { console.error("Error during initial theme/layout/logo application:", err); applyThemeAndLayout(DEFAULT_THEME_BG, DEFAULT_THEME_TEXT, DEFAULT_ELEMENT_LAYOUTS); setGlobalLogoState(null); }
    // === 04b: THEME & LAYOUT APPLICATION END ===

    // === 04c: DRAG AND DROP LOGIC START ===
    function startDrag(event, element) { if (event.button !== 0 || isModalOpen) return; event.preventDefault(); draggedElement = element; isDragging = true; const rect = element.getBoundingClientRect(); offsetX = event.clientX - rect.left; offsetY = event.clientY - rect.top; element.classList.add('dragging'); document.addEventListener('mousemove', doDrag); document.addEventListener('mouseup', endDrag); document.addEventListener('mouseleave', endDrag); }
    function doDrag(event) { if (!isDragging || !draggedElement) return; event.preventDefault(); const canvasRect = liveCanvas.getBoundingClientRect(); const canvasWidth = canvasRect.width; const canvasHeight = canvasRect.height; let newXpx = event.clientX - canvasRect.left - offsetX; let newYpx = event.clientY - canvasRect.top - offsetY; let newXPercent = (newXpx / canvasWidth) * 100; let newYPercent = (newYpx / canvasHeight) * 100; const elementWidthPercent = (draggedElement.offsetWidth / canvasWidth) * 100; const elementHeightPercent = (draggedElement.offsetHeight / canvasHeight) * 100; newXPercent = Math.max(0, Math.min(newXPercent, 100 - elementWidthPercent)); newYPercent = Math.max(0, Math.min(newYPercent, 100 - elementHeightPercent)); draggedElement.style.left = `${newXPercent}%`; draggedElement.style.top = `${newYPercent}%`; }
    function endDrag(event) { if (!isDragging || !draggedElement) return; event.preventDefault(); const elementId = draggedElement.id.replace('-element', ''); console.log(`Drag ended for ${elementId}`); draggedElement.classList.remove('dragging'); document.removeEventListener('mousemove', doDrag); document.removeEventListener('mouseup', endDrag); document.removeEventListener('mouseleave', endDrag); const canvasRect = liveCanvas.getBoundingClientRect(); const finalLeftPx = draggedElement.offsetLeft; const finalTopPx = draggedElement.offsetTop; const finalXPercent = parseFloat(((finalLeftPx / canvasRect.width) * 100).toFixed(2)); const finalYPercent = parseFloat(((finalTopPx / canvasRect.height) * 100).toFixed(2)); let currentLayouts = loadElementLayouts(); if (currentLayouts[elementId]) { currentLayouts[elementId].x = finalXPercent; currentLayouts[elementId].y = finalYPercent; saveElementLayouts(currentLayouts); console.log(`Saved new pos for ${elementId}: x=${finalXPercent}%, y=${finalYPercent}%`); if (isModalOpen && currentOpenModal === uiSettingsModal) { originalElementLayouts[elementId].x = finalXPercent; originalElementLayouts[elementId].y = finalYPercent; } } else console.error(`Could not find layout key '${elementId}'`); isDragging = false; draggedElement = null; }
    // === 04c: DRAG AND DROP LOGIC END ===

    // === 05: HELPER FUNCTIONS - FORMATTING START ===
    function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) return "00:00"; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
    function formatBlindsHTML(level) { if (!level) return `<span class="value">--</span>/<span class="value">--</span><span class="label">A:</span><span class="value">--</span>`; let anteHtml = ''; if (level.ante > 0) anteHtml = `<span class="label">A:</span><span class="value">${level.ante.toLocaleString('nb-NO')}</span>`; const sbFormatted = (level.sb ?? '--').toLocaleString('nb-NO'); const bbFormatted = (level.bb ?? '--').toLocaleString('nb-NO'); return `<span class="value">${sbFormatted}</span>/<span class="value">${bbFormatted}</span>${anteHtml}`; }
    function formatNextBlindsText(level) { if (!level) return "Slutt"; const anteText = level.ante > 0 ? ` / A:${level.ante.toLocaleString('nb-NO')}` : ''; const sbFormatted = (level.sb ?? '--').toLocaleString('nb-NO'); const bbFormatted = (level.bb ?? '--').toLocaleString('nb-NO'); return `${sbFormatted}/${bbFormatted}${anteText}`; }
    function getPlayerNameById(playerId) { const targetId = Number(playerId); const player = state.live.players.find(p => p.id === targetId) || state.live.eliminatedPlayers.find(p => p.id === targetId); return player ? player.name : 'Ukjent'; }
    function roundToNearestValid(value, step = 100) { if (isNaN(value) || value <= 0) return step; const rounded = Math.round(value / step) * step; return Math.max(step, rounded); }
    // === 05: HELPER FUNCTIONS - FORMATTING END ===

    // === 06: HELPER FUNCTIONS - CALCULATIONS START ===
    function calculateTotalChips() { const sChips = (state.live.totalEntries || 0) * (state.config.startStack || 0); const rChips = (state.live.totalRebuys || 0) * (state.config.rebuyChips || 0); const aChips = (state.live.totalAddons || 0) * (state.config.addonChips || 0); return sChips + rChips + aChips; }
    function calculateAverageStack() { const ap = state.live.players.length; if (ap === 0) return 0; const tc = calculateTotalChips(); return Math.round(tc / ap); }
    function calculatePrizes() { const prizes = []; const places = state.config.paidPlaces || 0; const dist = state.config.prizeDistribution || []; const pot = state.live.totalPot || 0; let pPot = pot; if (state.config.type === 'knockout' && (state.config.bountyAmount || 0) > 0) pPot -= (state.live.totalEntries || 0) * (state.config.bountyAmount || 0); pPot = Math.max(0, pPot); if (pPot <= 0 || places <= 0 || dist.length !== places) return prizes; let sum = 0; for (let i = 0; i < places; i++) { const pct = dist[i] || 0; let amt; if (i === places - 1) amt = Math.max(0, pPot - sum); else amt = Math.floor((pPot * pct) / 100); prizes.push({ place: i + 1, amount: amt, percentage: pct }); sum += amt; } if (Math.abs(sum - pPot) > 1 && places > 1) console.warn(`Prize calc warning: Sum ${sum} != Pot ${pPot}`); return prizes; }
    function findNextPauseInfo() { const idx = state.live.currentLevelIndex; const lvls = state.config.blindLevels; if (!lvls) return null; const startIdx = state.live.isOnBreak ? idx + 1 : idx; for (let i = startIdx; i < lvls.length; i++) { if (lvls[i].pauseMinutes > 0) return { level: lvls[i].level, duration: lvls[i].pauseMinutes }; } return null; }
    // === 06: HELPER FUNCTIONS - CALCULATIONS END ===

    // === 07: HELPER FUNCTIONS - TABLE MANAGEMENT START ===
    function assignTableSeat(player, excludeTableNum = null) { const tables = {}; let validTables = []; state.live.players.forEach(p => { if (p.id !== player.id && p.table && p.table !== excludeTableNum) tables[p.table] = (tables[p.table] || 0) + 1; }); validTables = Object.entries(tables).map(([n, c]) => ({ tableNum: parseInt(n), count: c })).filter(t => t.tableNum !== excludeTableNum); validTables.sort((a, b) => a.count - b.count); let targetTable = -1; for (const t of validTables) { if (t.count < state.config.playersPerTable) { targetTable = t.tableNum; break; } } if (targetTable === -1) { const existing = [...new Set(state.live.players.map(p => p.table).filter(t => t > 0))]; let nextT = existing.length > 0 ? Math.max(0, ...existing) + 1 : 1; if (nextT === excludeTableNum) nextT++; targetTable = nextT; } const occupied = state.live.players.filter(p => p.table === targetTable).map(p => p.seat); let seat = 1; while (occupied.includes(seat)) seat++; if (seat > state.config.playersPerTable && occupied.length >= state.config.playersPerTable) { console.error(`No seat on T${targetTable}!`); seat = occupied.length + 1; } player.table = targetTable; player.seat = seat; console.log(`Assigned ${player.name} -> T${player.table}S${player.seat}`); }
    function reassignAllSeats(targetTableNum) { logActivity(state.live.activityLog, `Finalebord (B${targetTableNum})! Trekker seter...`); const players = state.live.players; const numP = players.length; if (numP === 0) return; const seats = Array.from({ length: numP }, (_, i) => i + 1); for (let i = seats.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [seats[i], seats[j]] = [seats[j], seats[i]]; } players.forEach((p, i) => { p.table = targetTableNum; p.seat = seats[i]; logActivity(state.live.activityLog, ` -> ${p.name} S${p.seat}.`); }); state.live.players.sort((a, b) => a.seat - b.seat); console.log("Final table seats assigned."); }
    function checkAndHandleTableBreak() { if (state.live.status === 'finished') return false; const pCount = state.live.players.length; const maxPPT = state.config.playersPerTable; const tablesSet = new Set(state.live.players.map(p => p.table).filter(t => t > 0)); const tableCount = tablesSet.size; const targetTCount = Math.ceil(pCount / maxPPT); const finalTSize = maxPPT; console.log(`Table check: Players=${pCount}, Tables=${tableCount}, Target=${targetTCount}`); let action = false; if (tableCount > 1 && pCount <= finalTSize) { const finalTNum = 1; logActivity(state.live.activityLog, `Finalebord (${pCount})! Flytter til B${finalTNum}...`); alert(`Finalebord (${pCount})! Flytter til B${finalTNum}.`); playSound('FINAL_TABLE'); state.live.players.forEach(p => p.table = finalTNum); reassignAllSeats(finalTNum); action = true; } else if (tableCount > targetTCount && tableCount > 1) { const tables = {}; state.live.players.forEach(p => { if(p.table > 0) tables[p.table] = (tables[p.table] || 0) + 1; }); const sortedTs = Object.entries(tables).map(([n, c]) => ({ tableNum: parseInt(n), count: c })).sort((a, b) => a.count - b.count); if (sortedTs.length > 0) { const breakTNum = sortedTs[0].tableNum; const msg = `Sl√•r sammen! Flytter fra B${breakTNum}.`; logActivity(state.live.activityLog, msg); alert(msg); const toMove = state.live.players.filter(p => p.table === breakTNum); toMove.forEach(p => { const oT = p.table; const oS = p.seat; p.table = 0; p.seat = 0; assignTableSeat(p, breakTNum); logActivity(state.live.activityLog, ` -> ${p.name} (B${oT}S${oS}) til B${p.table}S${p.seat}.`); }); state.live.players.sort((a, b) => a.table === b.table ? a.seat - b.seat : a.table - b.table); action = true; } } const balanced = balanceTables(); if (action && !balanced) { updateUI(); saveTournamentState(currentTournamentId, state); } else if (!action && !balanced) { if (tableBalanceInfo) tableBalanceInfo.classList.add('hidden'); } return action || balanced; }
    function balanceTables() { if (state.live.status === 'finished' || state.live.players.length <= state.config.playersPerTable) { if (tableBalanceInfo) tableBalanceInfo.classList.add('hidden'); return false; } let balanced = false; const maxDiff = 1; while (true) { const tables = {}; state.live.players.forEach(p => { if(p.table > 0) tables[p.table] = (tables[p.table] || 0) + 1; }); const tableCounts = Object.entries(tables).map(([n, c]) => ({ tableNum: parseInt(n), count: c })).filter(tc => tc.count > 0); if (tableCounts.length < 2) { if (tableBalanceInfo) tableBalanceInfo.classList.add('hidden'); break; } tableCounts.sort((a, b) => a.count - b.count); const minT = tableCounts[0]; const maxT = tableCounts[tableCounts.length - 1]; if (maxT.count - minT.count <= maxDiff) { if (tableBalanceInfo) tableBalanceInfo.classList.add('hidden'); break; } balanced = true; if (tableBalanceInfo) tableBalanceInfo.classList.remove('hidden'); console.log(`Balancing: MaxT${maxT.tableNum}(${maxT.count}), MinT${minT.tableNum}(${minT.count})`); const maxPlayers = state.live.players.filter(p => p.table === maxT.tableNum); if (maxPlayers.length === 0) { console.error(`Balance Err: No players on maxT ${maxT.tableNum}`); if (tableBalanceInfo) tableBalanceInfo.textContent = "FEIL!"; break; } const pMove = maxPlayers[Math.floor(Math.random() * maxPlayers.length)]; const minSeats = state.live.players.filter(p => p.table === minT.tableNum).map(p => p.seat); let newS = 1; while(minSeats.includes(newS)) { newS++; } if(newS > state.config.playersPerTable) { console.error(`Balance Err: No seat on minT ${minT.tableNum}.`); alert(`Feil: Fant ikke sete p√• B${minT.tableNum}.`); if (tableBalanceInfo) tableBalanceInfo.textContent = "FEIL!"; break; } const oldT = pMove.table; const oldS = pMove.seat; const msg = `Balansering: ${pMove.name} fra B${oldT}S${oldS} til B${minT.tableNum}S${newS}.`; pMove.table = minT.tableNum; pMove.seat = newS; logActivity(state.live.activityLog, msg); state.live.players.sort((a, b) => a.table === b.table ? a.seat - b.seat : a.table - b.table); updateUI(); saveTournamentState(currentTournamentId, state); } if (balanced) console.log("Balancing done."); return balanced; }
    // === 07: HELPER FUNCTIONS - TABLE MANAGEMENT END ===

    // === 07b: HELPER FUNCTIONS - LOGGING START ===
    function logActivity(logArray, message) { if (!logArray) logArray = state.live.activityLog = []; const timestamp = new Date().toLocaleTimeString('nb-NO', { hour: '2-digit', minute: '2-digit', second: '2-digit' }); logArray.unshift({ timestamp, message }); const MAX_LOG_ENTRIES = 100; if (logArray.length > MAX_LOG_ENTRIES) logArray.pop(); console.log(`[Log ${timestamp}] ${message}`); }
    function renderActivityLog() { if (!activityLogUl) return; activityLogUl.innerHTML = ''; const logEntries = state?.live?.activityLog || []; if (logEntries.length === 0) { activityLogUl.innerHTML = '<li>Loggen er tom.</li>'; return; } logEntries.forEach(entry => { const li = document.createElement('li'); li.innerHTML = `<span class="log-time">[${entry.timestamp}]</span> ${entry.message}`; activityLogUl.appendChild(li); }); }
    // === 07b: HELPER FUNCTIONS - LOGGING END ===

    // === 07c: HELPER FUNCTIONS - SOUND START ===
    function playSound(soundKey) { if (!soundsEnabled) return; const soundUrl = SOUND_URLS[soundKey]; if (!soundUrl) { console.warn(`Sound not found: ${soundKey}`); return; } try { const audio = new Audio(soundUrl); audio.volume = currentVolume; audio.play().catch(e => console.error(`Play fail ${soundUrl}:`, e)); console.log(`Playing: ${soundKey} at volume ${currentVolume}`); } catch (e) { console.error(`Audio obj fail ${soundUrl}:`, e); } }
    function updateSoundToggleVisuals() { if (btnToggleSound) btnToggleSound.textContent = soundsEnabled ? 'üîä Lyd P√•' : 'üîá Lyd Av'; }
    // === 07c: HELPER FUNCTIONS - SOUND END ===

    // === 08: UI UPDATE FUNCTIONS START ===
    function renderPlayerList() { if (!playerListUl || !eliminatedPlayerListUl || !activePlayerCountSpan || !eliminatedPlayerCountSpan) { console.error("Player list elements missing!"); return; } playerListUl.innerHTML = ''; eliminatedPlayerListUl.innerHTML = ''; const currentLevelIndex = state.live.currentLevelIndex; const isRebuyPeriod = state.config.type === 'rebuy' && (currentLevelIndex < state.config.rebuyLevels); const isAddonAvailable = state.config.type === 'rebuy' && !state.live.status !== 'finished' && ( (currentLevelIndex >= state.config.rebuyLevels) || (currentLevelIndex === state.config.rebuyLevels - 1 && state.live.isOnBreak) ); const actionsOk = state.live.status !== 'finished'; const activeSorted = [...state.live.players].sort((a, b) => a.table === b.table ? a.seat - b.seat : a.table - b.table); activeSorted.forEach(p => { const li = document.createElement('li'); let info = `${p.name} <span class="player-details">(B${p.table}S${p.seat})</span>`; if (p.rebuys > 0) info += ` <span class="player-details">[${p.rebuys}R]</span>`; if (p.addon) info += ` <span class="player-details">[A]</span>`; if (state.config.type === 'knockout' && p.knockouts > 0) info += ` <span class="player-details">(KOs: ${p.knockouts})</span>`; let acts = ''; if (actionsOk) { acts += `<button class="btn-edit-player small-button" data-player-id="${p.id}" title="Rediger Spiller">‚úèÔ∏è</button>`; if (isRebuyPeriod) acts += `<button class="btn-rebuy small-button" data-player-id="${p.id}" title="Rebuy">R</button>`; if(state.config.type === 'rebuy' && !p.addon) { const addonButtonDisabled = isAddonAvailable; const addonButtonTitle = isAddonAvailable ? "Bruk 'Administrer Add-ons'" : "Add-on (ikke aktiv)"; acts += `<button class="btn-addon small-button" data-player-id="${p.id}" title="${addonButtonTitle}" ${addonButtonDisabled ? 'disabled style="opacity: 0.3;"' : ''}>A</button>`; } acts += `<button class="btn-eliminate small-button danger-button" data-player-id="${p.id}" title="Eliminer">X</button>`; } li.innerHTML = `<span class="item-name">${info}</span><div class="list-actions player-actions">${acts}</div>`; playerListUl.appendChild(li); }); const elimSorted = [...state.live.eliminatedPlayers].sort((a, b) => (a.place ?? Infinity) - (b.place ?? Infinity)); elimSorted.forEach(p => { const li = document.createElement('li'); let info = `${p.place ?? '?'}. ${p.name}`; if (p.rebuys > 0) info += ` <span class="player-details">[${p.rebuys}R]</span>`; if (p.addon) info += ` <span class="player-details">[A]</span>`; if (state.config.type === 'knockout' && p.knockouts > 0) info += ` <span class="player-details">(KOs: ${p.knockouts})</span>`; if (p.eliminatedBy) info += ` <span class="player-details">(av ${getPlayerNameById(p.eliminatedBy)})</span>`; let acts = ''; if (actionsOk) { acts += `<button class="btn-edit-player small-button" data-player-id="${p.id}" title="Rediger Spiller">‚úèÔ∏è</button>`; acts += `<button class="btn-restore small-button warning-button" data-player-id="${p.id}" title="Gjenopprett">‚Ü©Ô∏è</button>`; } li.innerHTML = `<span class="item-name">${info}</span><div class="list-actions player-actions">${acts}</div>`; eliminatedPlayerListUl.appendChild(li); }); activePlayerCountSpan.textContent = state.live.players.length; eliminatedPlayerCountSpan.textContent = state.live.eliminatedPlayers.length; playerListUl.querySelectorAll('.btn-edit-player').forEach(b => b.onclick = handleEditPlayerClick); playerListUl.querySelectorAll('.btn-rebuy').forEach(b => b.onclick = handleRebuy); playerListUl.querySelectorAll('.btn-eliminate').forEach(b => b.onclick = handleEliminate); eliminatedPlayerListUl.querySelectorAll('.btn-edit-player').forEach(b => b.onclick = handleEditPlayerClick); eliminatedPlayerListUl.querySelectorAll('.btn-restore').forEach(b => b.onclick = handleRestore); }
    function displayPrizes() { if (!prizeDisplayLive || !totalPotPrizeSpan) return; const prizeData = calculatePrizes(); const totalPotFmt = (state.live.totalPot || 0).toLocaleString('nb-NO'); prizeDisplayLive.querySelector('h3').innerHTML = `Premiefordeling (Totalpott: <span id="total-pot">${totalPotFmt}</span> kr)`; const ol = prizeDisplayLive.querySelector('ol'); const p = prizeDisplayLive.querySelector('p'); if(ol) ol.remove(); if(p) p.remove(); if (prizeData.length > 0) { const list = document.createElement('ol'); prizeData.forEach(pr => { const item = document.createElement('li'); item.textContent = `${pr.place}.: ${pr.amount.toLocaleString('nb-NO')} kr (${pr.percentage}%)`; list.appendChild(item); }); prizeDisplayLive.appendChild(list); prizeDisplayLive.classList.remove('hidden'); } else { const msgP = document.createElement('p'); const places = state.config.paidPlaces || 0; const dist = state.config.prizeDistribution || []; const totPot = state.live.totalPot || 0; let pPot = totPot; if (state.config.type === 'knockout') pPot -= (state.live.totalEntries || 0) * (state.config.bountyAmount || 0); if (pPot <= 0 && totPot > 0) msgP.textContent = 'Ingen pott √• fordele (etter bounty).'; else if (pPot <= 0) msgP.textContent = 'Ingen pott √• fordele.'; else if (places <= 0) msgP.textContent = 'Antall betalte ikke definert.'; else if (dist.length !== places) msgP.textContent = 'Premier matcher ikke betalte plasser.'; else msgP.textContent = 'Premiefordeling N/A.'; prizeDisplayLive.appendChild(msgP); prizeDisplayLive.classList.add('hidden'); } }
    function updateUI() { console.log("updateUI: Updating main UI elements..."); if (!state?.config || !state.live) { console.error("State missing in updateUI"); if(nameDisplay) nameDisplay.textContent = "Error!"; return; } if (nameDisplay) nameDisplay.textContent = state.config.name; if (currentTimeDisplay) currentTimeDisplay.textContent = new Date().toLocaleTimeString('nb-NO', { hour: '2-digit', minute: '2-digit', second: '2-digit' }); const currentLevelIndex = state.live.currentLevelIndex; const cl = state.config.blindLevels?.[currentLevelIndex]; const nl = state.config.blindLevels?.[currentLevelIndex + 1]; const np = findNextPauseInfo(); if (state.live.isOnBreak) { if(timerDisplay) timerDisplay.textContent = formatTime(state.live.timeRemainingInBreak); if(blindsElement) blindsElement.classList.add('hidden'); if(breakInfo) breakInfo.classList.remove('hidden'); } else { if(timerDisplay) timerDisplay.textContent = formatTime(state.live.timeRemainingInLevel); if(blindsElement) blindsElement.classList.remove('hidden'); if(breakInfo) breakInfo.classList.add('hidden'); if(currentLevelDisplay) currentLevelDisplay.textContent = `(Niv√• ${cl ? cl.level : 'N/A'})`; if(blindsDisplay) blindsDisplay.innerHTML = formatBlindsHTML(cl); } if (nextBlindsDisplay) nextBlindsDisplay.textContent = formatNextBlindsText(nl); if (averageStackDisplay) averageStackDisplay.textContent = calculateAverageStack().toLocaleString('nb-NO'); if (playersRemainingDisplay) playersRemainingDisplay.textContent = state.live.players.length; if (totalEntriesDisplay) totalEntriesDisplay.textContent = state.live.totalEntries; const currentLevelNum = currentLevelIndex + 1; const lrOpen = currentLevelNum <= state.config.lateRegLevel && state.config.lateRegLevel > 0 && state.live.status !== 'finished'; if (lateRegStatusDisplay) { if (state.config.lateRegLevel > 0) lateRegStatusDisplay.textContent = `${lrOpen ? `√Öpen t.o.m. niv√• ${state.config.lateRegLevel}` : 'Stengt'}`; else lateRegStatusDisplay.textContent = 'Ikke aktiv'; } if (infoNextPauseParagraph) { const span = infoNextPauseParagraph.querySelector('#next-pause-time'); if (span) span.textContent = np ? `Etter niv√• ${np.level} (${np.duration} min)` : 'Ingen flere'; } const isFin = state.live.status === 'finished'; if (startPauseButton) { startPauseButton.textContent = state.live.status === 'running' ? 'Pause Klokke' : 'Start Klokke'; startPauseButton.disabled = isFin; } if (prevLevelButton) prevLevelButton.disabled = currentLevelIndex <= 0 || isFin; if (nextLevelButton) nextLevelButton.disabled = currentLevelIndex >= state.config.blindLevels.length - 1 || isFin; if (adjustTimeMinusButton) adjustTimeMinusButton.disabled = isFin; if (adjustTimePlusButton) adjustTimePlusButton.disabled = isFin; if (lateRegButton) lateRegButton.disabled = !lrOpen || isFin; if (btnEditTournamentSettings) btnEditTournamentSettings.disabled = isFin; if (endTournamentButton) endTournamentButton.disabled = isFin; const isAddonAvailable = state.config.type === 'rebuy' && !isFin && ( (currentLevelIndex >= state.config.rebuyLevels) || (currentLevelIndex === state.config.rebuyLevels - 1 && state.live.isOnBreak) ); if (btnManageAddons) { btnManageAddons.classList.toggle('hidden', state.config.type !== 'rebuy'); btnManageAddons.disabled = !isAddonAvailable; } updateSoundToggleVisuals(); renderPlayerList(); displayPrizes(); renderActivityLog(); console.log("updateUI: Main UI elements updated."); }
    // === 08: UI UPDATE FUNCTIONS END ===

    // === 09: TIMER LOGIC START ===
    function tick() { if (state.live.status !== 'running') return; if (state.live.isOnBreak) { state.live.timeRemainingInBreak--; if (timerDisplay) timerDisplay.textContent = formatTime(state.live.timeRemainingInBreak); if (state.live.timeRemainingInBreak < 0) { state.live.isOnBreak = false; state.live.currentLevelIndex++; if (state.live.currentLevelIndex >= state.config.blindLevels.length) { logActivity(state.live.activityLog, "Pause ferdig. Blindstruktur fullf√∏rt."); playSound('PAUSE_END'); finishTournament(); return; } const newLvl = state.config.blindLevels[state.live.currentLevelIndex]; state.live.timeRemainingInLevel = newLvl.duration * 60; logActivity(state.live.activityLog, `Pause over. Niv√• ${newLvl.level} (${formatBlindsHTML(newLvl)}) starter.`); playSound('PAUSE_END'); setTimeout(() => playSound('NEW_LEVEL'), 500); updateUI(); saveTournamentState(currentTournamentId, state); } else if (state.live.timeRemainingInBreak % 15 === 0) saveTournamentState(currentTournamentId, state); } else { state.live.timeRemainingInLevel--; if (timerDisplay) timerDisplay.textContent = formatTime(state.live.timeRemainingInLevel); if (state.live.timeRemainingInLevel < 0) { const currentLvl = state.config.blindLevels[state.live.currentLevelIndex]; const pause = currentLvl?.pauseMinutes || 0; if (pause > 0) { state.live.isOnBreak = true; state.live.timeRemainingInBreak = pause * 60; logActivity(state.live.activityLog, `Niv√• ${currentLvl.level} ferdig. Starter ${pause} min pause.`); playSound('PAUSE_START'); updateUI(); saveTournamentState(currentTournamentId, state); } else { state.live.currentLevelIndex++; if (state.live.currentLevelIndex >= state.config.blindLevels.length) { logActivity(state.live.activityLog, `Niv√• ${currentLvl.level} ferdig. Blindstruktur fullf√∏rt.`); playSound('NEW_LEVEL'); finishTournament(); return; } const newLvl = state.config.blindLevels[state.live.currentLevelIndex]; state.live.timeRemainingInLevel = newLvl.duration * 60; logActivity(state.live.activityLog, `Niv√• ${currentLvl.level} ferdig. Niv√• ${newLvl.level} (${formatBlindsHTML(newLvl)}) starter.`); playSound('NEW_LEVEL'); updateUI(); saveTournamentState(currentTournamentId, state); } } else if (state.live.timeRemainingInLevel > 0 && state.live.timeRemainingInLevel % 30 === 0) saveTournamentState(currentTournamentId, state); } }
    function startRealTimeClock() { if (realTimeInterval) clearInterval(realTimeInterval); realTimeInterval = setInterval(() => { if (currentTimeDisplay) currentTimeDisplay.textContent = new Date().toLocaleTimeString('nb-NO', { hour: '2-digit', minute: '2-digit', second: '2-digit' }); }, 1000); }
    // === 09: TIMER LOGIC END ===

    // === 10: EVENT HANDLERS - CONTROLS START ===
    function handleStartPause() { console.log("handleStartPause called. Current status:", state.live.status); if (!state || !state.live) { console.error("State not ready in handleStartPause"); return; } if (state.live.status === 'finished') { console.log("handleStartPause: Tournament finished, doing nothing."); return; } if (state.live.status === 'paused') { state.live.status = 'running'; if (!timerInterval) { timerInterval = setInterval(tick, 1000); console.log("handleStartPause: Timer interval started."); } logActivity(state.live.activityLog, "Klokke startet."); } else if (state.live.status === 'running') { state.live.status = 'paused'; if (timerInterval) { clearInterval(timerInterval); timerInterval = null; console.log("handleStartPause: Timer interval cleared."); } logActivity(state.live.activityLog, "Klokke pauset."); saveTournamentState(currentTournamentId, state); } else { console.warn("handleStartPause called with unexpected status:", state.live.status); } updateUI(); }
    function handleAdjustTime(deltaSeconds) { console.log("handleAdjustTime called."); if (state.live.status === 'finished') return; let key = state.live.isOnBreak ? 'timeRemainingInBreak' : 'timeRemainingInLevel'; let maxT = Infinity; if (!state.live.isOnBreak) { const lvl = state.config.blindLevels[state.live.currentLevelIndex]; if (lvl) maxT = lvl.duration * 60; } state.live[key] = Math.max(0, Math.min(state.live[key] + deltaSeconds, maxT)); logActivity(state.live.activityLog, `Tid justert ${deltaSeconds > 0 ? '+' : ''}${deltaSeconds / 60} min.`); updateUI(); saveTournamentState(currentTournamentId, state); }
    function handleAdjustLevel(deltaIndex) { console.log("handleAdjustLevel called."); if (state.live.status === 'finished') return; const newIdx = state.live.currentLevelIndex + deltaIndex; if (newIdx >= 0 && newIdx < state.config.blindLevels.length) { const oldLvlNum = state.config.blindLevels[state.live.currentLevelIndex]?.level || '?'; const newLvl = state.config.blindLevels[newIdx]; if (!confirm(`Endre til Niv√• ${newLvl.level} (${formatBlindsHTML(newLvl)})?\nKlokken nullstilles.`)) return; state.live.currentLevelIndex = newIdx; state.live.timeRemainingInLevel = newLvl.duration * 60; state.live.isOnBreak = false; state.live.timeRemainingInBreak = 0; logActivity(state.live.activityLog, `Niv√• manuelt endret: ${oldLvlNum} -> ${newLvl.level}.`); playSound('NEW_LEVEL'); updateUI(); saveTournamentState(currentTournamentId, state); } else alert("Kan ikke g√• til niv√•et."); }
    function handleEndTournament() { console.log("handleEndTournament called."); if (state.live.status === 'finished') { alert("Turneringen er allerede fullf√∏rt."); return; } if (confirm("Markere turneringen som fullf√∏rt?")) finishTournament(); }
    function handleForceSave() { console.log("handleForceSave called."); if (state) { console.log("Forcing save..."); if (saveTournamentState(currentTournamentId, state)) { if(btnForceSave) btnForceSave.textContent = "Lagret!"; setTimeout(() => { if(btnForceSave) btnForceSave.textContent = "Lagre N√•"; }, 1500); } else alert("Lagring feilet!"); } else console.error("State missing on force save."); }
    function handleBackToMain() { console.log("handleBackToMain called."); if (state && state.live.status !== 'finished') saveTournamentState(currentTournamentId, state); window.location.href = 'index.html'; }
    // === 10: EVENT HANDLERS - CONTROLS END ===

    // === 11: EVENT HANDLERS - PLAYER ACTIONS START ===
    function handleRebuy(event){ console.log("handleRebuy raw dataset ID:", event?.target?.dataset?.playerId); const playerId = Number(event?.target?.dataset?.playerId); console.log("handleRebuy called for player ID:", playerId); if (!playerId || isNaN(playerId)) { console.error("Rebuy: Invalid player ID from button."); return; } const p=state.live.players.find(pl=>pl.id===playerId); const lvl=state.live.currentLevelIndex+1; if(!p){ console.warn(`Rebuy: Player ${playerId} not found in active list.`); return; } if(state.config.type!=='rebuy'||!(lvl<=state.config.rebuyLevels)){alert("Re-buy er ikke tilgjengelig n√•.");return;} if(state.live.status==='finished'){alert("Turnering er fullf√∏rt.");return;} if(confirm(`Re-buy (${state.config.rebuyCost}kr/${state.config.rebuyChips}c) for ${p.name}?`)){ p.rebuys=(p.rebuys||0)+1; state.live.totalPot+=state.config.rebuyCost; state.live.totalEntries++; state.live.totalRebuys++; logActivity(state.live.activityLog,`${p.name} tok Re-buy.`); updateUI(); saveTournamentState(currentTournamentId,state);} }
    function handleEliminate(event){ console.log("handleEliminate raw dataset ID:", event?.target?.dataset?.playerId); const playerId = Number(event?.target?.dataset?.playerId); console.log("handleEliminate called for player ID:", playerId); if (!playerId || isNaN(playerId)) { console.error("Eliminate: Invalid player ID from button."); return; } if(state.live.status === 'finished') return; const ap = state.live.players; const pI = ap.findIndex(p=>p.id===playerId); if(pI === -1) { console.warn(`Eliminate: Player ${playerId} not found in active list.`); const alreadyEliminated = state.live.eliminatedPlayers.find(p => p.id === playerId); if (alreadyEliminated) { console.warn(`Player ${playerId} is already eliminated.`); alert(`${alreadyEliminated.name} er allerede sl√•tt ut.`); } else { alert(`Fant ikke spiller med ID ${playerId} i listen over aktive spillere.`); } return; } if (ap.length <= 1 && state.live.status !== 'finished') { alert("Kan ikke eliminere siste spiller f√∏r turneringen er fullf√∏rt."); return; } const p = ap[pI]; let koId = null; if (state.config.type === 'knockout' && (state.config.bountyAmount || 0) > 0) { const assigners = ap.filter(pl => pl.id !== playerId); if (assigners.length === 0) { console.log("Only one other player left, no KO assignment possible."); koId = null; proceed(); return; } const overlay = document.createElement('div'); overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);display:flex;justify-content:center;align-items:center;z-index:200;'; const box = document.createElement('div'); box.style.cssText = 'background:#fff;color:#333;padding:25px;border-radius:5px;text-align:center;max-width:400px;box-shadow:0 5px 15px rgba(0,0,0,0.3);'; box.innerHTML = `<h3 style="margin-top:0;margin-bottom:15px;color:#333;">Hvem slo ut ${p.name}?</h3><select id="ko-sel" style="padding:8px;margin:10px 0 20px 0;min-width:250px;max-width:100%;border:1px solid #ccc;border-radius:4px;font-size:1em;"><option value="">-- Velg --</option><option value="none">Ingen KO / Delt pott</option>${assigners.map(pl => `<option value="${pl.id}">${pl.name} (B${pl.table}S${pl.seat})</option>`).join('')}</select><div><button id="ko-ok" class="success-button" style="margin-right:10px;padding:8px 15px;font-size:0.95em;">Bekreft</button><button id="ko-cancel" style="padding:8px 15px;font-size:0.95em;">Avbryt</button></div>`; overlay.appendChild(box); document.body.appendChild(overlay); const closeKo = () => { if (document.body.contains(overlay)) document.body.removeChild(overlay); }; document.getElementById('ko-ok').onclick = () => { const selVal = document.getElementById('ko-sel').value; if (!selVal) { alert("Velg spiller eller 'Ingen KO'."); return; } koId = (selVal === "none") ? null : Number(selVal); closeKo(); proceed(); }; document.getElementById('ko-cancel').onclick = () => { closeKo(); console.log("KO selection cancelled."); }; } else { koId = null; proceed(); } function proceed() { let koName = null; let koObj = null; if (koId !== null && !isNaN(koId)) { koObj = ap.find(pl => pl.id === koId); if (koObj) { koName = koObj.name; } else { console.warn("Selected KO player not found in active list:", koId); koId = null; } } const confirmMsg = `Eliminere ${p.name}?` + (koName ? ` (KO til ${koName})` : ''); if (confirm(confirmMsg)) { playSound('KNOCKOUT'); p.eliminated = true; p.eliminatedBy = koId; const playersRemainingBefore = ap.length; p.place = playersRemainingBefore; if (koObj) { koObj.knockouts = (koObj.knockouts || 0) + 1; state.live.knockoutLog.push({ eliminatedPlayerId: p.id, eliminatedByPlayerId: koObj.id, level: state.live.currentLevelIndex + 1, timestamp: new Date().toISOString() }); console.log(`KO: ${koObj.name} took out ${p.name}`); } state.live.eliminatedPlayers.push(p); ap.splice(pI, 1); const logTxt = koName ? ` av ${koName}` : ''; logActivity(state.live.activityLog, `${p.name} sl√•tt ut (${p.place}. plass${logTxt}).`); console.log(`Player ${p.name} eliminated. ${ap.length} remaining.`); if (state.config.paidPlaces > 0 && ap.length === state.config.paidPlaces) { logActivity(state.live.activityLog, `Boblen sprakk! ${ap.length} spillere igjen (i pengene).`); playSound('BUBBLE'); } const structChanged = checkAndHandleTableBreak(); if (!structChanged) { updateUI(); saveTournamentState(currentTournamentId, state); } if (state.live.players.length <= 1 && state.live.status !== 'finished') { finishTournament(); } } else { console.log("Elimination cancelled."); } } }
    function handleRestore(event){ console.log("handleRestore raw dataset ID:", event?.target?.dataset?.playerId); const playerId = Number(event?.target?.dataset?.playerId); console.log("handleRestore called for player ID:", playerId); if (!playerId || isNaN(playerId)) { console.error("Restore: Invalid player ID from button."); return; } if(state.live.status==='finished'){ alert("Turnering fullf√∏rt."); return; } const pI=state.live.eliminatedPlayers.findIndex(p=>p.id===playerId); if(pI===-1) { console.warn(`Restore: Player ${playerId} not found in eliminated list.`); return; } const p=state.live.eliminatedPlayers[pI]; const oldP = p.place; if(confirm(`Gjenopprette ${p.name} (var ${oldP}.plass)?`)){ const koById = p.eliminatedBy; p.eliminated = false; p.eliminatedBy = null; p.place = null; state.live.eliminatedPlayers.splice(pI, 1); state.live.players.push(p); if(state.config.type === 'knockout' && koById){ let koGetter = state.live.players.find(pl => pl.id === koById) || state.live.eliminatedPlayers.find(pl => pl.id === koById); if(koGetter?.knockouts > 0){ koGetter.knockouts--; console.log(`KO reversed for ${koGetter.name}.`); const logI = state.live.knockoutLog.findIndex(l => l.eliminatedPlayerId === p.id && l.eliminatedByPlayerId === koById); if(logI > -1) { state.live.knockoutLog.splice(logI, 1); } } else if (koGetter) { console.warn(`Restore: KO getter ${koGetter.name} found, but had ${koGetter.knockouts} KOs.`); } } assignTableSeat(p); logActivity(state.live.activityLog, `${p.name} gjenopprettet fra ${oldP}.plass (n√• B${p.table}S${p.seat}).`); const structChanged = checkAndHandleTableBreak(); if (!structChanged) { updateUI(); saveTournamentState(currentTournamentId, state); } } }
    function handleEditPlayerClick(event) { console.log("handleEditPlayerClick raw dataset ID:", event?.target?.dataset?.playerId); const playerId = Number(event?.target?.dataset?.playerId); console.log("handleEditPlayerClick called for player ID:", playerId); if (!playerId || isNaN(playerId)) { console.error("handleEditPlayerClick: Invalid or missing player ID."); return; } if (state.live.status === 'finished') return; openEditPlayerModal(playerId); }
    function handleLateRegClick() { console.log("handleLateRegClick called."); if(state.live.status === 'finished') return; const lvl=state.live.currentLevelIndex + 1; const isOpen = lvl <= state.config.lateRegLevel && state.config.lateRegLevel > 0; if (!isOpen) { const reason = state.config.lateRegLevel > 0 ? `stengte etter niv√• ${state.config.lateRegLevel}` : "ikke aktivert"; alert(`Sen registrering ${reason}.`); return; } const name = prompt("Navn (Late Reg):"); if (name?.trim()) { const newPlayerId = state.live.nextPlayerId++; const p={ id: newPlayerId, name:name.trim(), stack:state.config.startStack, table:0, seat:0, rebuys:0, addon:false, eliminated:false, eliminatedBy:null, place:null, knockouts:0 }; assignTableSeat(p); state.live.players.push(p); state.live.totalPot+=state.config.buyIn; state.live.totalEntries++; logActivity(state.live.activityLog,`${p.name} (ID: ${p.id}) registrert (Late Reg, B${p.table}S${p.seat}).`); state.live.players.sort((a,b)=>a.table===b.table?a.seat-b.seat:a.table-b.table); const structChanged = checkAndHandleTableBreak(); if(!structChanged){updateUI(); saveTournamentState(currentTournamentId,state);} } else if(name !== null) { alert("Navn kan ikke v√¶re tomt."); } }
    // === 11: EVENT HANDLERS - PLAYER ACTIONS END ===

    // === 12: EVENT HANDLERS - MODAL & EDIT SETTINGS START ===
    function openTournamentModal() { if (state.live.status === 'finished' || isModalOpen) return; console.log("Opening T modal"); const modalContent = tournamentSettingsModal.querySelector('.modal-content'); if (!modalContent) { console.error("Tournament modal content not found!"); return; } const editBlindStructureBody = modalContent.querySelector('#edit-blind-structure-body'); const btnAddEditLevel = modalContent.querySelector('#btn-add-edit-level'); const editPaidPlacesInput = modalContent.querySelector('#edit-paid-places'); const editPrizeDistTextarea = modalContent.querySelector('#edit-prize-distribution'); const btnGenerateEditPayout = modalContent.querySelector('#btn-generate-edit-payout'); const btnSaveTournamentSettings = modalContent.querySelector('#btn-save-tournament-settings'); const btnCancelTournamentEdit = modalContent.querySelector('#btn-cancel-tournament-edit'); const closeTournamentModalButton = modalContent.querySelector('#close-tournament-modal-button'); if (!editBlindStructureBody || !btnAddEditLevel || !editPaidPlacesInput || !editPrizeDistTextarea || !btnGenerateEditPayout || !btnSaveTournamentSettings || !btnCancelTournamentEdit || !closeTournamentModalButton) { console.error("One or more elements inside tournament modal not found!"); return; } editBlindStructureBody.innerHTML = ''; editBlindLevelCounter = 0; state.config.blindLevels.forEach(level => addEditBlindLevelRow(level)); updateEditLevelNumbers(); editPaidPlacesInput.value = state.config.paidPlaces; editPrizeDistTextarea.value = state.config.prizeDistribution.join(', '); closeTournamentModalButton.onclick = closeTournamentModal; btnCancelTournamentEdit.onclick = closeTournamentModal; btnAddEditLevel.onclick = () => addEditBlindLevelRow(); btnGenerateEditPayout.onclick = generateEditPayout; btnSaveTournamentSettings.onclick = handleSaveTournamentSettings; tournamentSettingsModal.classList.remove('hidden'); isModalOpen = true; currentOpenModal = tournamentSettingsModal; }
    function closeTournamentModal() { if (!tournamentSettingsModal) return; const btnAddEditLevel = tournamentSettingsModal.querySelector('#btn-add-edit-level'); const btnGenerateEditPayout = tournamentSettingsModal.querySelector('#btn-generate-edit-payout'); const btnSaveTournamentSettings = tournamentSettingsModal.querySelector('#btn-save-tournament-settings'); const btnCancelTournamentEdit = tournamentSettingsModal.querySelector('#btn-cancel-tournament-edit'); const closeTournamentModalButton = tournamentSettingsModal.querySelector('#close-tournament-modal-button'); closeTournamentModalButton.onclick = null; btnCancelTournamentEdit.onclick = null; btnAddEditLevel.onclick = null; btnGenerateEditPayout.onclick = null; btnSaveTournamentSettings.onclick = null; tournamentSettingsModal.classList.add('hidden'); isModalOpen = false; currentOpenModal = null; }
    async function openUiModal() { if (isModalOpen) return; console.log("Opening UI modal"); originalThemeBg = loadThemeBgColor(); originalThemeText = loadThemeTextColor(); originalElementLayouts = loadElementLayouts(); originalSoundVolume = loadSoundVolume(); console.log("Opening UI modal: Fetching logo blob..."); const initialBlob = await loadLogoBlob(); logoBlobInModal = initialBlob; console.log("Opening UI modal: Logo blob fetched:", logoBlobInModal); const modalContent = uiSettingsModal.querySelector('.modal-content'); if (!modalContent) { console.error("UI modal content not found"); return; } // Hent kontroller INNI modalen const canvasHeightSlider = modalContent.querySelector('#canvasHeightSlider'); const canvasHeightInput = modalContent.querySelector('#canvasHeightInput'); const visibilityToggles = Array.from(modalContent.querySelectorAll('.element-visibility-toggles input[type="checkbox"]')); const sizeSliders = Array.from(modalContent.querySelectorAll('.element-layout-grid input[type="range"]')); const sizeInputs = Array.from(modalContent.querySelectorAll('.element-layout-grid input[type="number"]')); const internalInfoToggles = Array.from(modalContent.querySelectorAll('.info-toggles input[type="checkbox"]')); const customLogoInput = modalContent.querySelector('#customLogoInput'); const logoPreview = modalContent.querySelector('#logoPreview'); const btnRemoveCustomLogo = modalContent.querySelector('#btnRemoveCustomLogo'); const colorSliders = Array.from(modalContent.querySelectorAll('.theme-editor-color input[type="range"]')); const colorInputs = Array.from(modalContent.querySelectorAll('.theme-editor-color input[type="number"]')); const predefinedThemeSelect = modalContent.querySelector('#predefinedThemeSelect'); const btnLoadPredefinedTheme = modalContent.querySelector('#btnLoadPredefinedTheme'); const themeFavoritesSelect = modalContent.querySelector('#themeFavoritesSelect'); const btnLoadThemeFavorite = modalContent.querySelector('#btnLoadThemeFavorite'); const newThemeFavoriteNameInput = modalContent.querySelector('#newThemeFavoriteName'); const btnSaveThemeFavorite = modalContent.querySelector('#btnSaveThemeFavorite'); const btnDeleteThemeFavorite = modalContent.querySelector('#btnDeleteThemeFavorite'); const volumeSlider = modalContent.querySelector('#volumeSlider'); const volumeInput = modalContent.querySelector('#volumeInput'); const btnTestSound = modalContent.querySelector('#btn-test-sound'); const btnResetLayoutTheme = modalContent.querySelector('#btnResetLayoutTheme'); const btnSaveUiSettings = modalContent.querySelector('#btn-save-ui-settings'); const btnCancelUiEdit = modalContent.querySelector('#btn-cancel-ui-edit'); const closeUiModalButton = modalContent.querySelector('#close-ui-modal-button'); const bgColorPreview = modalContent.querySelector('#bg-color-preview'); const textColorPreview = modalContent.querySelector('#text-color-preview'); blockSliderUpdates=true; try { const [bgR, bgG, bgB] = parseRgbString(originalThemeBg); const bgHSL = rgbToHsl(bgR, bgG, bgB); const [textR, textG, textB] = parseRgbString(originalThemeText); const textHSL = rgbToHsl(textR, textG, textB); const layouts = originalElementLayouts; if(modalContent.querySelector('#bgRedSlider')) modalContent.querySelector('#bgRedSlider').value = bgR; if(modalContent.querySelector('#bgRedInput')) modalContent.querySelector('#bgRedInput').value = bgR; if(modalContent.querySelector('#bgGreenSlider')) modalContent.querySelector('#bgGreenSlider').value = bgG; if(modalContent.querySelector('#bgGreenInput')) modalContent.querySelector('#bgGreenInput').value = bgG; if(modalContent.querySelector('#bgBlueSlider')) modalContent.querySelector('#bgBlueSlider').value = bgB; if(modalContent.querySelector('#bgBlueInput')) modalContent.querySelector('#bgBlueInput').value = bgB; if(modalContent.querySelector('#bgHueSlider')) modalContent.querySelector('#bgHueSlider').value = bgHSL.h; if(modalContent.querySelector('#bgHueInput')) modalContent.querySelector('#bgHueInput').value = bgHSL.h; if(modalContent.querySelector('#bgSatSlider')) modalContent.querySelector('#bgSatSlider').value = bgHSL.s; if(modalContent.querySelector('#bgSatInput')) modalContent.querySelector('#bgSatInput').value = bgHSL.s; if(modalContent.querySelector('#bgLigSlider')) modalContent.querySelector('#bgLigSlider').value = bgHSL.l; if(modalContent.querySelector('#bgLigInput')) modalContent.querySelector('#bgLigInput').value = bgHSL.l; if(modalContent.querySelector('#textRedSlider')) modalContent.querySelector('#textRedSlider').value = textR; if(modalContent.querySelector('#textRedInput')) modalContent.querySelector('#textRedInput').value = textR; if(modalContent.querySelector('#textGreenSlider')) modalContent.querySelector('#textGreenSlider').value = textG; if(modalContent.querySelector('#textGreenInput')) modalContent.querySelector('#textGreenInput').value = textG; if(modalContent.querySelector('#textBlueSlider')) modalContent.querySelector('#textBlueSlider').value = textB; if(modalContent.querySelector('#textBlueInput')) modalContent.querySelector('#textBlueInput').value = textB; if(modalContent.querySelector('#textHueSlider')) modalContent.querySelector('#textHueSlider').value = textHSL.h; if(modalContent.querySelector('#textHueInput')) modalContent.querySelector('#textHueInput').value = textHSL.h; if(modalContent.querySelector('#textSatSlider')) modalContent.querySelector('#textSatSlider').value = textHSL.s; if(modalContent.querySelector('#textSatInput')) modalContent.querySelector('#textSatInput').value = textHSL.s; if(modalContent.querySelector('#textLigSlider')) modalContent.querySelector('#textLigSlider').value = textHSL.l; if(modalContent.querySelector('#textLigInput')) modalContent.querySelector('#textLigInput').value = textHSL.l; if (canvasHeightInput && canvasHeightSlider && layouts.canvas) { canvasHeightInput.value = canvasHeightSlider.value = layouts.canvas.height; } else { console.error("Missing canvas height controls or layout data"); } if (titleWidthInput && titleWidthSlider && layouts.title) { titleWidthInput.value = titleWidthSlider.value = layouts.title.width; } else { console.error("Missing title width controls or layout data"); } if (titleFontSizeInput && titleFontSizeSlider && layouts.title) { titleFontSizeInput.value = titleFontSizeSlider.value = layouts.title.fontSize; } else { console.error("Missing title font size controls or layout data"); } if (timerWidthInput && timerWidthSlider && layouts.timer) { timerWidthInput.value = timerWidthSlider.value = layouts.timer.width; } else { console.error("Missing timer width controls or layout data"); } if(timerFontSizeInput && timerFontSizeSlider && layouts.timer?.fontSize !== undefined) { timerFontSizeInput.value = layouts.timer.fontSize; timerFontSizeSlider.value = layouts.timer.fontSize; } else { console.error("Missing timer font size controls or layout data"); } if (blindsWidthInput && blindsWidthSlider && layouts.blinds) { blindsWidthInput.value = blindsWidthSlider.value = layouts.blinds.width; } else { console.error("Missing blinds width controls or layout data"); } if (blindsFontSizeInput && blindsFontSizeSlider && layouts.blinds) { blindsFontSizeInput.value = blindsFontSizeSlider.value = layouts.blinds.fontSize; } else { console.error("Missing blinds font size controls or layout data"); } if (logoWidthInput && logoWidthSlider && layouts.logo) { logoWidthInput.value = logoWidthSlider.value = layouts.logo.width; } else { console.error("Missing logo width controls or layout data"); } if (logoHeightInput && logoHeightSlider && layouts.logo) { logoHeightInput.value = logoHeightSlider.value = layouts.logo.height; } else { console.error("Missing logo height controls or layout data"); } if (infoWidthInput && infoWidthSlider && layouts.info) { infoWidthInput.value = infoWidthSlider.value = layouts.info.width; } else { console.error("Missing info width controls or layout data"); } if (infoFontSizeInput && infoFontSizeSlider && layouts.info) { infoFontSizeInput.value = infoFontSizeSlider.value = layouts.info.fontSize; } else { console.error("Missing info font size controls or layout data"); } visibilityToggles.forEach(toggle => { if(toggle){ const elId = toggle.dataset.elementId.replace('-element',''); toggle.checked = layouts[elId]?.isVisible ?? true; }}); for (const key in infoParagraphs) { const cbId = `toggleInfo${key.substring(4)}`; const cb = modalContent.querySelector(`#${cbId}`); if (cb && layouts.info) cb.checked = layouts.info[key] ?? true; } if(volumeInput) volumeInput.value = originalSoundVolume; if(volumeSlider) volumeSlider.value = originalSoundVolume; console.log("Opening UI modal: Updating preview image..."); updateImageSrc(logoBlobInModal, logoPreview, true); if(customLogoInput) customLogoInput.value = ''; } catch (err) { console.error("Error populating UI modal controls:", err); alert("Feil ved fylling av UI-innstillinger."); blockSliderUpdates = false; return; } finally { blockSliderUpdates = false; } populatePredefinedThemes(); populateThemeFavorites(); enableDisableDeleteButton(); addThemeAndLayoutListeners(); closeUiModalButton.onclick = () => closeUiModal(true); btnCancelUiEdit.onclick = () => closeUiModal(true); btnSaveUiSettings.onclick = handleSaveUiSettings; btnResetLayoutTheme.onclick = handleResetLayoutTheme; uiSettingsModal.classList.remove('hidden'); isModalOpen = true; currentOpenModal = uiSettingsModal; console.log("Opening UI modal: Modal is now open."); }
    async function closeUiModal(revert = false) { console.log(`Closing UI modal. Revert: ${revert}`); revokeObjectUrl(previewLogoObjectUrl); previewLogoObjectUrl = null; if (revert) { console.log("Closing UI modal: Reverting changes..."); applyThemeAndLayout(originalThemeBg, originalThemeText, originalElementLayouts); currentVolume = originalSoundVolume; const storedBlob = await loadLogoBlob(); console.log("Closing UI modal: Re-applying original logo blob:", storedBlob); updateImageSrc(storedBlob, logoImg, false); console.log("Closing UI modal: Revert complete."); } else { console.log("Closing UI modal: No revert needed."); updateImageSrc(currentLogoBlob, logoImg, false); } removeThemeAndLayoutListeners(); uiSettingsModal.classList.add('hidden'); isModalOpen = false; currentOpenModal = null; console.log("Closing UI modal: Modal closed."); }
    function addEditBlindLevelRow(levelData={}){ editBlindLevelCounter++; const row=editBlindStructureBody.insertRow(); row.dataset.levelNumber=editBlindLevelCounter; const sb=levelData.sb??''; const bb=levelData.bb??''; const ante=levelData.ante??0; const dur=levelData.duration??(state.config.blindLevels?.[0]?.duration||20); const pause=levelData.pauseMinutes??0; const past = levelData.level <= state.live.currentLevelIndex && !state.live.isOnBreak; const dis = past ? 'disabled' : ''; row.innerHTML=`<td><span class="level-number">${editBlindLevelCounter}</span> ${past?'<small>(L√•st)</small>':''}</td><td><input type="number" class="sb-input" value="${sb}" min="0" step="1" ${dis}></td><td><input type="number" class="bb-input" value="${bb}" min="0" step="1" ${dis}></td><td><input type="number" class="ante-input" value="${ante}" min="0" step="1" ${dis}></td><td><input type="number" class="duration-input" value="${dur}" min="1" ${dis}></td><td><input type="number" class="pause-duration-input" value="${pause}" min="0" ${dis}></td><td><button type="button" class="btn-remove-level" title="Fjern niv√• ${editBlindLevelCounter}" ${dis}>X</button></td>`; const btn=row.querySelector('.btn-remove-level'); if(!past) btn.onclick=()=>{row.remove(); updateEditLevelNumbers();}; else { row.querySelectorAll('input').forEach(inp=>inp.disabled=true); btn.disabled=true; } }
    function updateEditLevelNumbers(){ const rows=editBlindStructureBody.querySelectorAll('tr'); rows.forEach((r,i)=>{ const lvl=i+1; r.dataset.levelNumber=lvl; r.querySelector('.level-number').textContent=lvl; const btn=r.querySelector('.btn-remove-level'); if(btn)btn.title=`Fjern niv√• ${lvl}`; }); editBlindLevelCounter=rows.length; }
    function generateEditPayout(){ const editPaidPlacesInput = document.getElementById('edit-paid-places'); const editPrizeDistTextarea = document.getElementById('edit-prize-distribution'); const p=parseInt(editPaidPlacesInput.value)||0; editPrizeDistTextarea.value = (p > 0 && standardPayouts[p]) ? standardPayouts[p].join(', ') : ''; }
    function syncRgbFromHsl(prefix){ if(blockSliderUpdates) return; const h=parseInt(document.getElementById(`${prefix}HueInput`).value); const s=parseInt(document.getElementById(`${prefix}SatInput`).value); const l=parseInt(document.getElementById(`${prefix}LigInput`).value); const rgb=hslToRgb(h,s,l); const [r,g,b]=parseRgbString(rgb); blockSliderUpdates=true; document.getElementById(`${prefix}RedSlider`).value=document.getElementById(`${prefix}RedInput`).value=r; document.getElementById(`${prefix}GreenSlider`).value=document.getElementById(`${prefix}GreenInput`).value=g; document.getElementById(`${prefix}BlueSlider`).value=document.getElementById(`${prefix}BlueInput`).value=b; blockSliderUpdates=false; return rgb; }
    function syncHslFromRgb(prefix){ if(blockSliderUpdates) return; const r=parseInt(document.getElementById(`${prefix}RedInput`).value); const g=parseInt(document.getElementById(`${prefix}GreenInput`).value); const b=parseInt(document.getElementById(`${prefix}BlueInput`).value); const hsl=rgbToHsl(r,g,b); blockSliderUpdates=true; document.getElementById(`${prefix}HueSlider`).value=document.getElementById(`${prefix}HueInput`).value=hsl.h; document.getElementById(`${prefix}SatSlider`).value=document.getElementById(`${prefix}SatInput`).value=hsl.s; document.getElementById(`${prefix}LigSlider`).value=document.getElementById(`${prefix}LigInput`).value=hsl.l; blockSliderUpdates=false; return `rgb(${r}, ${g}, ${b})`; }
    function updateColorAndLayoutPreviews() { if (!isModalOpen || currentOpenModal !== uiSettingsModal) return; const modalContent = uiSettingsModal.querySelector('.modal-content'); if(!modalContent) return; const bg = syncHslFromRgb('bg'); const txt = syncHslFromRgb('text'); const layouts = { canvas:{height:parseInt(modalContent.querySelector('#canvasHeightInput').value)} }; const currentFullLayouts = loadElementLayouts(); Array.from(modalContent.querySelectorAll('.element-visibility-toggles input[type="checkbox"]')).forEach(toggle => { const elementId = toggle.dataset.elementId.replace('-element',''); const widthSlider = modalContent.querySelector(`#${elementId}WidthSlider`); const fontSizeSlider = modalContent.querySelector(`#${elementId}FontSizeSlider`); const heightSlider = modalContent.querySelector(`#${elementId}HeightSlider`); layouts[elementId] = { ...(currentFullLayouts[elementId] || DEFAULT_ELEMENT_LAYOUTS[elementId]), width: parseInt(widthSlider?.value ?? (currentFullLayouts[elementId]?.width || DEFAULT_ELEMENT_LAYOUTS[elementId].width)), fontSize: parseFloat(fontSizeSlider?.value ?? (currentFullLayouts[elementId]?.fontSize || DEFAULT_ELEMENT_LAYOUTS[elementId].fontSize)), height: parseInt(heightSlider?.value ?? (currentFullLayouts[elementId]?.height || DEFAULT_ELEMENT_LAYOUTS[elementId].height)), isVisible: toggle.checked, x: originalElementLayouts[elementId]?.x ?? DEFAULT_ELEMENT_LAYOUTS[elementId].x, y: originalElementLayouts[elementId]?.y ?? DEFAULT_ELEMENT_LAYOUTS[elementId].y, }; if (elementId === 'info') { layouts.info.showNextBlinds = modalContent.querySelector('#toggleInfoNextBlinds').checked; layouts.info.showNextPause = modalContent.querySelector('#toggleInfoNextPause').checked; layouts.info.showAvgStack = modalContent.querySelector('#toggleInfoAvgStack').checked; layouts.info.showPlayers = modalContent.querySelector('#toggleInfoPlayers').checked; layouts.info.showLateReg = modalContent.querySelector('#toggleInfoLateReg').checked; } }); const bgColorPreview = modalContent.querySelector('#bg-color-preview'); const textColorPreview = modalContent.querySelector('#text-color-preview'); if(bgColorPreview) bgColorPreview.style.backgroundColor = bg; if(textColorPreview) { textColorPreview.style.backgroundColor = bg; textColorPreview.querySelector('span').style.color = txt; } applyThemeAndLayout(bg, txt, layouts); }
    function handleThemeLayoutControlChange(e) { if (!isModalOpen || currentOpenModal !== uiSettingsModal) return; const target = e.target; const id = target.id; const isSlider = id.includes('Slider'); const isInput = id.includes('Input'); if (target === volumeSlider || target === volumeInput) { const newVol = parseFloat(target.value); if(!isNaN(newVol)) { currentVolume = Math.max(0, Math.min(1, newVol)); if (target === volumeSlider && volumeInput) volumeInput.value = currentVolume.toFixed(2); if (target === volumeInput && volumeSlider) volumeSlider.value = currentVolume.toFixed(2); } } else if (target === toggleLogoElement) { console.log("Logo visibility toggle changed:", target.checked); } else if (isSlider || isInput) { const baseId = isSlider ? id.replace('Slider', '') : id.replace('Input', ''); const slider = document.getElementById(baseId + 'Slider'); const input = document.getElementById(baseId + 'Input'); if (target.type === 'number' && input) { let val = parseFloat(target.value); const min = parseFloat(target.min||'0'); const max = parseFloat(target.max||'100'); const step = parseFloat(target.step||'1'); if (!isNaN(val)) { val = Math.max(min, Math.min(max, val)); target.value = (step % 1 === 0) ? Math.round(val) : val.toFixed(step.toString().split('.')[1]?.length || 1); if (slider) slider.value = target.value; } } else if (isSlider && input) { input.value = target.value; } if (id.includes('Hue') || id.includes('Sat') || id.includes('Lig')) { syncRgbFromHsl(id.startsWith('bg') ? 'bg' : 'text'); } else if (id.includes('Red') || id.includes('Green') || id.includes('Blue')) { syncHslFromRgb(id.startsWith('bg') ? 'bg' : 'text'); } } updateColorAndLayoutPreviews(); }
    // ENDRET: Listeners legges n√• til dynamisk
    function addThemeAndLayoutListeners(){ console.log("Adding UI Modal Listeners"); const modalContent = uiSettingsModal.querySelector('.modal-content'); if(!modalContent) return; // Hent elementene p√• nytt her const sizeSlidersDyn = Array.from(modalContent.querySelectorAll('.element-layout-grid input[type="range"]')); const sizeInputsDyn = Array.from(modalContent.querySelectorAll('.element-layout-grid input[type="number"]')); const colorSlidersDyn = Array.from(modalContent.querySelectorAll('.theme-editor-color input[type="range"]')); const colorInputsDyn = Array.from(modalContent.querySelectorAll('.theme-editor-color input[type="number"]')); const visibilityTogglesDyn = Array.from(modalContent.querySelectorAll('.element-visibility-toggles input[type="checkbox"]')); const internalInfoTogglesDyn = Array.from(modalContent.querySelectorAll('.info-toggles input[type="checkbox"]')); const volumeSliderDyn = modalContent.querySelector('#volumeSlider'); const volumeInputDyn = modalContent.querySelector('#volumeInput'); const btnTestSoundDyn = modalContent.querySelector('#btn-test-sound'); const customLogoInputDyn = modalContent.querySelector('#customLogoInput'); const btnRemoveCustomLogoDyn = modalContent.querySelector('#btnRemoveCustomLogo'); const btnLoadPredefinedThemeDyn = modalContent.querySelector('#btnLoadPredefinedTheme'); const btnLoadThemeFavoriteDyn = modalContent.querySelector('#btnLoadThemeFavorite'); const btnSaveThemeFavoriteDyn = modalContent.querySelector('#btnSaveThemeFavorite'); const btnDeleteThemeFavoriteDyn = modalContent.querySelector('#btnDeleteThemeFavorite'); const themeFavoritesSelectDyn = modalContent.querySelector('#themeFavoritesSelect'); const predefinedThemeSelectDyn = modalContent.querySelector('#predefinedThemeSelect'); sizeSlidersDyn.forEach(el => el?.addEventListener('input', handleThemeLayoutControlChange)); sizeInputsDyn.forEach(el => el?.addEventListener('input', handleThemeLayoutControlChange)); colorSlidersDyn.forEach(el => el?.addEventListener('input', handleThemeLayoutControlChange)); colorInputsDyn.forEach(el => el?.addEventListener('input', handleThemeLayoutControlChange)); visibilityTogglesDyn.forEach(el => el?.addEventListener('change', handleThemeLayoutControlChange)); internalInfoTogglesDyn.forEach(el => el?.addEventListener('change', handleThemeLayoutControlChange)); volumeSliderDyn?.addEventListener('input', handleThemeLayoutControlChange); volumeInputDyn?.addEventListener('input', handleThemeLayoutControlChange); btnTestSoundDyn?.addEventListener('click', () => playSound('TEST')); customLogoInputDyn?.addEventListener('change', handleLogoUpload); btnRemoveCustomLogoDyn?.addEventListener('click', handleRemoveLogo); btnLoadPredefinedThemeDyn?.addEventListener('click', handleLoadPredefinedTheme); btnLoadThemeFavoriteDyn.addEventListener('click', handleLoadFavorite); btnSaveThemeFavoriteDyn.addEventListener('click', handleSaveFavorite); btnDeleteThemeFavoriteDyn.addEventListener('click', handleDeleteFavorite); themeFavoritesSelectDyn.addEventListener('change', enableDisableDeleteButton); predefinedThemeSelectDyn?.addEventListener('change', () => { if(btnLoadPredefinedThemeDyn) btnLoadPredefinedThemeDyn.disabled = !predefinedThemeSelectDyn.value; }); }
    // ENDRET: Listeners fjernes n√• dynamisk
    function removeThemeAndLayoutListeners(){ console.log("Removing UI Modal Listeners"); const modalContent = uiSettingsModal.querySelector('.modal-content'); if(!modalContent) return; // Hent elementene p√• nytt her const sizeSlidersDyn = Array.from(modalContent.querySelectorAll('.element-layout-grid input[type="range"]')); const sizeInputsDyn = Array.from(modalContent.querySelectorAll('.element-layout-grid input[type="number"]')); const colorSlidersDyn = Array.from(modalContent.querySelectorAll('.theme-editor-color input[type="range"]')); const colorInputsDyn = Array.from(modalContent.querySelectorAll('.theme-editor-color input[type="number"]')); const visibilityTogglesDyn = Array.from(modalContent.querySelectorAll('.element-visibility-toggles input[type="checkbox"]')); const internalInfoTogglesDyn = Array.from(modalContent.querySelectorAll('.info-toggles input[type="checkbox"]')); const volumeSliderDyn = modalContent.querySelector('#volumeSlider'); const volumeInputDyn = modalContent.querySelector('#volumeInput'); const btnTestSoundDyn = modalContent.querySelector('#btn-test-sound'); const customLogoInputDyn = modalContent.querySelector('#customLogoInput'); const btnRemoveCustomLogoDyn = modalContent.querySelector('#btnRemoveCustomLogo'); const btnLoadPredefinedThemeDyn = modalContent.querySelector('#btnLoadPredefinedTheme'); const btnLoadThemeFavoriteDyn = modalContent.querySelector('#btnLoadThemeFavorite'); const btnSaveThemeFavoriteDyn = modalContent.querySelector('#btnSaveThemeFavorite'); const btnDeleteThemeFavoriteDyn = modalContent.querySelector('#btnDeleteThemeFavorite'); const themeFavoritesSelectDyn = modalContent.querySelector('#themeFavoritesSelect'); const predefinedThemeSelectDyn = modalContent.querySelector('#predefinedThemeSelect'); sizeSlidersDyn.forEach(el => el?.removeEventListener('input', handleThemeLayoutControlChange)); sizeInputsDyn.forEach(el => el?.removeEventListener('input', handleThemeLayoutControlChange)); colorSlidersDyn.forEach(el => el?.removeEventListener('input', handleThemeLayoutControlChange)); colorInputsDyn.forEach(el => el?.removeEventListener('input', handleThemeLayoutControlChange)); visibilityTogglesDyn.forEach(el => el?.removeEventListener('change', handleThemeLayoutControlChange)); internalInfoTogglesDyn.forEach(el => el?.removeEventListener('change', handleThemeLayoutControlChange)); volumeSliderDyn?.removeEventListener('input', handleThemeLayoutControlChange); volumeInputDyn?.removeEventListener('input', handleThemeLayoutControlChange); btnTestSoundDyn?.removeEventListener('click', () => playSound('TEST')); customLogoInputDyn?.removeEventListener('change', handleLogoUpload); btnRemoveCustomLogoDyn?.removeEventListener('click', handleRemoveLogo); btnLoadPredefinedThemeDyn?.removeEventListener('click', handleLoadPredefinedTheme); btnLoadThemeFavoriteDyn.removeEventListener('click', handleLoadFavorite); btnSaveThemeFavoriteDyn.removeEventListener('click', handleSaveFavorite); btnDeleteThemeFavoriteDyn.removeEventListener('click', handleDeleteFavorite); themeFavoritesSelectDyn.removeEventListener('change', enableDisableDeleteButton); predefinedThemeSelectDyn?.removeEventListener('change', () => { /* Logikk inni her var un√∏dvendig */ }); }
    function populatePredefinedThemes() { const select = uiSettingsModal?.querySelector('#predefinedThemeSelect'); const btn = uiSettingsModal?.querySelector('#btnLoadPredefinedTheme'); if (!select || !btn) return; select.innerHTML = '<option value="">-- Velg et tema --</option>'; PREDEFINED_THEMES.forEach((theme, index) => { const option = document.createElement('option'); option.value = index.toString(); option.textContent = theme.name; select.appendChild(option); }); btn.disabled = true; }
    function handleLoadPredefinedTheme() { const select = uiSettingsModal?.querySelector('#predefinedThemeSelect'); const selectedIndex = select?.value; if (selectedIndex === "" || !PREDEFINED_THEMES[selectedIndex]) return; const theme = PREDEFINED_THEMES[selectedIndex]; console.log(`Loading predefined theme: ${theme.name}`); const [bgR,bgG,bgB]=parseRgbString(theme.bg); const bgHSL=rgbToHsl(bgR,bgG,bgB); const [txtR,txtG,txtB]=parseRgbString(theme.text); const txtHSL=rgbToHsl(txtR,txtG,txtB); blockSliderUpdates = true; /* ... sett verdier p√• sliders/inputs ... */ blockSliderUpdates = false; updateColorAndLayoutPreviews(); }
    function populateThemeFavorites() { const select = uiSettingsModal?.querySelector('#themeFavoritesSelect'); const btn = uiSettingsModal?.querySelector('#btnDeleteThemeFavorite'); if (!select || !btn) return; const favs = loadThemeFavorites(); select.innerHTML = '<option value="">Velg favoritt...</option>'; favs.forEach(f => { const opt = document.createElement('option'); opt.value = f.id; opt.textContent = f.name; select.appendChild(opt); }); enableDisableDeleteButton(); }
    function enableDisableDeleteButton(){ const select = uiSettingsModal?.querySelector('#themeFavoritesSelect'); const btn = uiSettingsModal?.querySelector('#btnDeleteThemeFavorite'); if(btn) btn.disabled = !select?.value; }
    function handleLoadFavorite() { const select = uiSettingsModal?.querySelector('#themeFavoritesSelect'); const id = select?.value; if (!id) return; const fav = loadThemeFavorites().find(f => f.id === id); if (fav) { console.log(`Loading favorite theme: ${fav.name}`); const [bgR,bgG,bgB]=parseRgbString(fav.bg); const bgHSL=rgbToHsl(bgR,bgG,bgB); const [txtR,txtG,txtB]=parseRgbString(fav.text); const txtHSL=rgbToHsl(txtR,txtG,txtB); blockSliderUpdates = true; /* ... sett verdier ... */ blockSliderUpdates = false; updateColorAndLayoutPreviews(); } }
    function handleSaveFavorite() { const input = uiSettingsModal?.querySelector('#newThemeFavoriteName'); const name = input?.value.trim(); if (!name) { alert("Skriv navn."); return; } const bg = `rgb(${uiSettingsModal?.querySelector('#bgRedInput').value}, ${uiSettingsModal?.querySelector('#bgGreenInput').value}, ${uiSettingsModal?.querySelector('#bgBlueInput').value})`; const txt = `rgb(${uiSettingsModal?.querySelector('#textRedInput').value}, ${uiSettingsModal?.querySelector('#textGreenInput').value}, ${uiSettingsModal?.querySelector('#textBlueInput').value})`; const saved = addThemeFavorite(name, bg, txt); input.value = ''; populateThemeFavorites(); const select = uiSettingsModal?.querySelector('#themeFavoritesSelect'); if(select) select.value = saved.id; enableDisableDeleteButton(); alert(`Tema '${saved.name}' lagret!`); console.log(`Theme saved: ${saved.name}`, saved); }
    function handleDeleteFavorite() { const select = uiSettingsModal?.querySelector('#themeFavoritesSelect'); const id = select?.value; if (!id) return; const fav = loadThemeFavorites().find(f => f.id === id); if (fav && confirm(`Slette tema '${fav.name}'?`)) { deleteThemeFavorite(id); populateThemeFavorites(); console.log(`Theme deleted: ${fav.name}`); } }
    function handleSaveTournamentSettings(){ console.log("Saving T settings..."); let changes=false; let uiUpdate=false; const cLI=state.live.currentLevelIndex; let valid=true; const newLvls=[]; const rows=document.getElementById('edit-blind-structure-body')?.querySelectorAll('tr'); if(!rows){ console.error("Could not find edit blind structure body"); return; } let errs=[]; if(rows.length===0){alert("Minst ett niv√• kreves.");return;} rows.forEach((row,idx)=>{ /* ... (som f√∏r) ... */ }); if(!valid){let msg="Ugyldige verdier:\n- "+[...new Set(errs)].join("\n- "); if(errs.length===0)msg="Ugyldige verdier (markerte felt)."; alert(msg); return;} if(JSON.stringify(state.config.blindLevels)!==JSON.stringify(newLvls)){state.config.blindLevels=newLvls;changes=true;uiUpdate=true;logActivity(state.live.activityLog,"Blindstruktur endret.");console.log("Blinds changed",newLvls);} const places=parseInt(document.getElementById('edit-paid-places')?.value); const dist=document.getElementById('edit-prize-distribution')?.value.split(',').map(p=>parseFloat(p.trim())).filter(p=>!isNaN(p)&&p>=0) || []; let prizesOk=true; let prizeErrs=[]; if(isNaN(places)||places<=0){prizesOk=false;prizeErrs.push("Ugyldig antall betalte (> 0).");}else if(dist.length!==places){prizesOk=false;prizeErrs.push(`Premier(${dist.length}) != Betalte(${places}).`);}else{const sum=dist.reduce((a,b)=>a+b,0);if(Math.abs(sum-100)>0.1){prizesOk=false;prizeErrs.push(`Sum (${sum.toFixed(1)}%) != 100%.`);}} if(!prizesOk){alert("Feil i premier:\n- "+prizeErrs.join("\n- "));return;} if(state.config.paidPlaces!==places||JSON.stringify(state.config.prizeDistribution)!==JSON.stringify(dist)){const inMoney=state.live.eliminatedPlayers.filter(p=>p.place&&p.place<=state.config.paidPlaces).length;if(inMoney===0||confirm(`Advarsel: ${inMoney} i pengene. Endre premier?`)){state.config.paidPlaces=places;state.config.prizeDistribution=dist;changes=true;uiUpdate=true;logActivity(state.live.activityLog,"Premiestruktur endret.");console.log("Prizes changed",places,dist);}else{console.log("Prize change cancelled.");document.getElementById('edit-paid-places').value=state.config.paidPlaces;document.getElementById('edit-prize-distribution').value=state.config.prizeDistribution.join(', ');return;}} if(changes){if(saveTournamentState(currentTournamentId,state)){alert("Regelendringer lagret!");if(uiUpdate)updateUI();closeTournamentModal();}else alert("Lagring feilet!");} else{alert("Ingen regelendringer √• lagre.");closeTournamentModal();}}
    async function handleSaveUiSettings(){ console.log("handleSaveUiSettings: Attempting to save..."); let themeCh=false, layoutCh=false, volumeCh=false, logoCh = false, success = true; const modalContent = uiSettingsModal.querySelector('.modal-content'); if(!modalContent) return; const bg=`rgb(${modalContent.querySelector('#bgRedInput').value}, ${modalContent.querySelector('#bgGreenInput').value}, ${modalContent.querySelector('#bgBlueInput').value})`; const txt=`rgb(${modalContent.querySelector('#textRedInput').value}, ${modalContent.querySelector('#textGreenInput').value}, ${modalContent.querySelector('#textBlueInput').value})`; if(bg!==originalThemeBg||txt!==originalThemeText){ saveThemeBgColor(bg); saveThemeTextColor(txt); console.log("Theme saved."); themeCh=true; originalThemeBg = bg; originalThemeText = txt;} const finalLayouts = { canvas:{height:parseInt(modalContent.querySelector('#canvasHeightInput').value)} }; Array.from(modalContent.querySelectorAll('.element-visibility-toggles input[type="checkbox"]')).forEach(toggle => { const elementId = toggle.dataset.elementId.replace('-element', ''); const widthSlider = modalContent.querySelector(`#${elementId}WidthSlider`); const fontSizeSlider = modalContent.querySelector(`#${elementId}FontSizeSlider`); const heightSlider = modalContent.querySelector(`#${elementId}HeightSlider`); finalLayouts[elementId] = { width: parseInt(widthSlider?.value ?? DEFAULT_ELEMENT_LAYOUTS[elementId].width), fontSize: parseFloat(fontSizeSlider?.value ?? DEFAULT_ELEMENT_LAYOUTS[elementId].fontSize), height: parseInt(heightSlider?.value ?? DEFAULT_ELEMENT_LAYOUTS[elementId].height), isVisible: toggle.checked, x: originalElementLayouts[elementId]?.x ?? DEFAULT_ELEMENT_LAYOUTS[elementId].x, y: originalElementLayouts[elementId]?.y ?? DEFAULT_ELEMENT_LAYOUTS[elementId].y, }; if (elementId === 'info') { finalLayouts.info.showNextBlinds = modalContent.querySelector('#toggleInfoNextBlinds').checked; finalLayouts.info.showNextPause = modalContent.querySelector('#toggleInfoNextPause').checked; finalLayouts.info.showAvgStack = modalContent.querySelector('#toggleInfoAvgStack').checked; finalLayouts.info.showPlayers = modalContent.querySelector('#toggleInfoPlayers').checked; finalLayouts.info.showLateReg = modalContent.querySelector('#toggleInfoLateReg').checked; } }); if(JSON.stringify(finalLayouts)!==JSON.stringify(originalElementLayouts)){ saveElementLayouts(finalLayouts); console.log("Layout saved."); layoutCh=true; originalElementLayouts = finalLayouts; } const finalVolume = parseFloat(modalContent.querySelector('#volumeInput').value); if (finalVolume !== originalSoundVolume) { saveSoundVolume(finalVolume); currentVolume = finalVolume; console.log("Volume saved."); volumeCh = true; originalSoundVolume = finalVolume; } console.log("handleSaveUiSettings: Comparing logo blobs. Modal:", logoBlobInModal, "Current:", currentLogoBlob); if (logoBlobInModal !== currentLogoBlob) { console.log("handleSaveUiSettings: Logo has changed."); if (logoBlobInModal === null) { console.log("handleSaveUiSettings: Clearing logo blob..."); if (!await clearLogoBlob()) { success = false; } else { console.log("Custom logo cleared from storage."); } } else { console.log("handleSaveUiSettings: Saving new logo blob..."); if (!await saveLogoBlob(logoBlobInModal)) { success = false; } else { console.log("Custom logo saved to storage."); } } if (success) { logoCh = true; setGlobalLogoState(logoBlobInModal); console.log("handleSaveUiSettings: currentLogoBlob updated."); } else { console.error("handleSaveUiSettings: Failed to save/clear logo."); return; } } else { console.log("handleSaveUiSettings: Logo unchanged."); } if (success && (themeCh || layoutCh || volumeCh || logoCh)) { console.log("handleSaveUiSettings: Changes detected and saved. Closing modal."); alert("Utseende & Lyd lagret!"); closeUiModal(false); } else if (success) { console.log("handleSaveUiSettings: No changes detected. Closing modal."); alert("Ingen endringer √• lagre."); closeUiModal(false); } }
    async function handleResetLayoutTheme() { if (confirm("Tilbakestille layout, farger, logo og lyd til standard?")) { console.log("handleResetLayoutTheme: Resetting..."); const dLayout = DEFAULT_ELEMENT_LAYOUTS; const dBg = DEFAULT_THEME_BG; const dTxt = DEFAULT_THEME_TEXT; const dVol = DEFAULT_SOUND_VOLUME; const resetLayouts = {}; for (const key in dLayout) { resetLayouts[key] = { ...dLayout[key], x: originalElementLayouts[key]?.x ?? dLayout[key].x, y: originalElementLayouts[key]?.y ?? dLayout[key].y }; } resetLayouts.info = { ...resetLayouts.info, ...dLayout.info }; applyThemeAndLayout(dBg, dTxt, resetLayouts); currentVolume = dVol; document.getElementById('volumeInput').value = document.getElementById('volumeSlider').value = dVol; logoBlobInModal = null; updateImageSrc(null, document.getElementById('logoPreview'), true); updateImageSrc(null, logoImg, false); document.getElementById('customLogoInput').value = ''; blockSliderUpdates=true; const [bgR,bgG,bgB]=parseRgbString(dBg); const bgHSL=rgbToHsl(bgR,bgG,bgB); document.getElementById('bgRedSlider').value=document.getElementById('bgRedInput').value=bgR; document.getElementById('bgGreenSlider').value=document.getElementById('bgGreenInput').value=bgG; document.getElementById('bgBlueSlider').value=document.getElementById('bgBlueInput').value=bgB; document.getElementById('bgHueSlider').value=document.getElementById('bgHueInput').value=bgHSL.h; document.getElementById('bgSatSlider').value=document.getElementById('bgSatInput').value=bgHSL.s; document.getElementById('bgLigSlider').value=document.getElementById('bgLigInput').value=bgHSL.l; const [txtR,txtG,txtB]=parseRgbString(dTxt); const txtHSL=rgbToHsl(txtR,txtG,txtB); document.getElementById('textRedSlider').value=document.getElementById('textRedInput').value=txtR; document.getElementById('textGreenSlider').value=document.getElementById('textGreenInput').value=txtG; document.getElementById('textBlueSlider').value=document.getElementById('textBlueInput').value=txtB; document.getElementById('textHueSlider').value=document.getElementById('textHueInput').value=txtHSL.h; document.getElementById('textSatSlider').value=document.getElementById('textSatInput').value=txtHSL.s; document.getElementById('textLigSlider').value=document.getElementById('textLigInput').value=txtHSL.l; document.getElementById('canvasHeightInput').value=document.getElementById('canvasHeightSlider').value=dLayout.canvas.height; document.getElementById('titleWidthInput').value=document.getElementById('titleWidthSlider').value=dLayout.title.width; document.getElementById('titleFontSizeInput').value=document.getElementById('titleFontSizeSlider').value=dLayout.title.fontSize; document.getElementById('timerWidthInput').value=document.getElementById('timerWidthSlider').value=dLayout.timer.width; document.getElementById('timerFontSizeInput').value=document.getElementById('timerFontSizeSlider').value=dLayout.timer.fontSize; document.getElementById('blindsWidthInput').value=document.getElementById('blindsWidthSlider').value=dLayout.blinds.width; document.getElementById('blindsFontSizeInput').value=document.getElementById('blindsFontSizeSlider').value=dLayout.blinds.fontSize; document.getElementById('logoWidthInput').value=document.getElementById('logoWidthSlider').value=dLayout.logo.width; document.getElementById('logoHeightInput').value=document.getElementById('logoHeightSlider').value=dLayout.logo.height; document.getElementById('infoWidthInput').value=document.getElementById('infoWidthSlider').value=dLayout.info.width; document.getElementById('infoFontSizeInput').value=document.getElementById('infoFontSizeSlider').value=dLayout.info.fontSize; document.querySelectorAll('.element-visibility-toggles input[type="checkbox"]').forEach(t => {const elId=t.dataset.elementId.replace('-element',''); t.checked=dLayout[elId]?.isVisible??true;}); for(const k in infoParagraphs){const checkId=`toggleInfo${k.substring(4)}`; const check=document.getElementById(checkId); if(check) check.checked=dLayout.info[k]??true;} blockSliderUpdates=false; alert("Layout/farger/lyd/logo tilbakestilt i modalen. Trykk Lagre for √• bruke endringene (inkludert fjerning av lagret logo)."); } }
    function handleLogoUpload(event) { const file = event.target.files[0]; console.log("handleLogoUpload: File selected:", file); if (!file) return; const validTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/svg+xml', 'image/webp']; if (!validTypes.includes(file.type)) { alert('Ugyldig filtype.'); customLogoInput.value = ''; return; } logoBlobInModal = file; console.log("handleLogoUpload: logoBlobInModal set to file object:", logoBlobInModal); console.log("handleLogoUpload: Updating preview..."); updateImageSrc(logoBlobInModal, document.getElementById('logoPreview'), true); console.log(`handleLogoUpload: Logo selected: ${file.name}. Ready to be saved.`); }
    function handleRemoveLogo() { if (confirm("Fjerne egendefinert logo og g√• tilbake til standard (krever Lagre)?")) { console.log("handleRemoveLogo: Removing logo in modal..."); logoBlobInModal = null; document.getElementById('customLogoInput').value = ''; console.log("handleRemoveLogo: Updating preview..."); updateImageSrc(null, document.getElementById('logoPreview'), true); console.log("handleRemoveLogo: Custom logo removed visually (pending save)."); } }
    function openAddonModal() { if (!addonModal || isModalOpen) return; console.log("Opening Addon Modal..."); const listUl = addonModal.querySelector('#addon-player-list'); const confirmBtn = addonModal.querySelector('#btn-confirm-addons'); const cancelBtn = addonModal.querySelector('#btn-cancel-addons'); const closeBtn = addonModal.querySelector('#close-addon-modal-button'); if(!listUl || !confirmBtn || !cancelBtn || !closeBtn) { console.error("Addon modal elements not found!"); return; } listUl.innerHTML = ''; const activePlayers = state.live.players; if (activePlayers.length === 0) { listUl.innerHTML = '<li>Ingen aktive spillere.</li>'; } else { activePlayers.forEach(player => { const li = document.createElement('li'); li.style.display = 'flex'; li.style.alignItems = 'center'; li.style.justifyContent = 'space-between'; li.style.padding = '5px 0'; const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = `addon-chk-${player.id}`; checkbox.dataset.playerId = player.id; checkbox.checked = player.addon; checkbox.disabled = player.addon; checkbox.style.marginRight = '10px'; const label = document.createElement('label'); label.htmlFor = `addon-chk-${player.id}`; label.textContent = player.name; label.style.flexGrow = '1'; if (player.addon) { label.style.opacity = '0.6'; } li.appendChild(checkbox); li.appendChild(label); listUl.appendChild(li); }); } closeBtn.onclick = closeAddonModal; cancelBtn.onclick = closeAddonModal; confirmBtn.onclick = handleConfirmAddons; addonModal.classList.remove('hidden'); isModalOpen = true; currentOpenModal = addonModal; }
    function closeAddonModal() { if (!addonModal) return; const confirmBtn = addonModal.querySelector('#btn-confirm-addons'); const cancelBtn = addonModal.querySelector('#btn-cancel-addons'); const closeBtn = addonModal.querySelector('#close-addon-modal-button'); if(confirmBtn) confirmBtn.onclick = null; if(cancelBtn) cancelBtn.onclick = null; if(closeBtn) closeBtn.onclick = null; addonModal.classList.add('hidden'); isModalOpen = false; currentOpenModal = null; }
    function handleConfirmAddons() { console.log("Confirming Addons..."); const listUl = addonModal.querySelector('#addon-player-list'); if(!listUl) return; const checkboxes = listUl.querySelectorAll('input[type="checkbox"]:not(:disabled)'); let addonsGiven = 0; let costTotal = 0; checkboxes.forEach(chk => { if (chk.checked) { const playerId = Number(chk.dataset.playerId); const player = state.live.players.find(p => p.id === playerId); if (player && !player.addon) { player.addon = true; state.live.totalAddons++; costTotal += state.config.addonCost || 0; logActivity(state.live.activityLog, `${player.name} tok Add-on.`); addonsGiven++; } } }); if (addonsGiven > 0) { state.live.totalPot += costTotal; console.log(`${addonsGiven} add-ons confirmed. Total cost added: ${costTotal}`); updateUI(); saveTournamentState(currentTournamentId, state); } else { console.log("No new add-ons selected."); } closeAddonModal(); }
    function openEditPlayerModal(playerId) { if (!editPlayerModal || isModalOpen) return; console.log(`Opening Edit Player Modal for ID: ${playerId}`); let player = state.live.players.find(p => p.id === playerId); const isEliminated = !player; if (isEliminated) { player = state.live.eliminatedPlayers.find(p => p.id === playerId); } if (!player) { console.error(`Player with ID ${playerId} not found.`); alert(`Feil: Fant ikke spiller med ID ${playerId}.`); return; } console.log("Player data:", player); const idInput = editPlayerModal.querySelector('#edit-player-id-input'); const nameDisplay = editPlayerModal.querySelector('#edit-player-name-display'); const nameInput = editPlayerModal.querySelector('#edit-player-name-input'); const rebuysInput = editPlayerModal.querySelector('#edit-player-rebuys-input'); const addonCheckbox = editPlayerModal.querySelector('#edit-player-addon-checkbox'); const saveBtn = editPlayerModal.querySelector('#btn-save-player-changes'); const cancelBtn = editPlayerModal.querySelector('#btn-cancel-player-edit'); const closeBtn = editPlayerModal.querySelector('#close-edit-player-modal-button'); if (!idInput || !nameDisplay || !nameInput || !rebuysInput || !addonCheckbox || !saveBtn || !cancelBtn || !closeBtn) { console.error("Edit player modal elements missing!"); return; } idInput.value = player.id; nameDisplay.textContent = player.name + (isEliminated ? ' (Eliminert)' : ` (B${player.table}S${player.seat})`); nameInput.value = player.name; rebuysInput.value = player.rebuys || 0; addonCheckbox.checked = player.addon || false; saveBtn.onclick = handleSaveChangesEditPlayer; cancelBtn.onclick = closeEditPlayerModal; closeBtn.onclick = closeEditPlayerModal; editPlayerModal.classList.remove('hidden'); isModalOpen = true; currentOpenModal = editPlayerModal; }
    function closeEditPlayerModal() { if (!editPlayerModal) return; const saveBtn = editPlayerModal.querySelector('#btn-save-player-changes'); const cancelBtn = editPlayerModal.querySelector('#btn-cancel-player-edit'); const closeBtn = editPlayerModal.querySelector('#close-edit-player-modal-button'); if(saveBtn) saveBtn.onclick = null; if(cancelBtn) cancelBtn.onclick = null; if(closeBtn) closeBtn.onclick = null; editPlayerModal.classList.add('hidden'); isModalOpen = false; currentOpenModal = null; }
    function handleSaveChangesEditPlayer() { const idInput = editPlayerModal.querySelector('#edit-player-id-input'); const nameInput = editPlayerModal.querySelector('#edit-player-name-input'); const rebuysInput = editPlayerModal.querySelector('#edit-player-rebuys-input'); const addonCheckbox = editPlayerModal.querySelector('#edit-player-addon-checkbox'); if(!idInput || !nameInput || !rebuysInput || !addonCheckbox) { console.error("Cannot save player changes, elements missing."); return;} const playerId = Number(idInput.value); if (!playerId || isNaN(playerId)) { console.error("Save Player Changes: Invalid ID in modal."); return; } let player = state.live.players.find(p => p.id === playerId); if (!player) { player = state.live.eliminatedPlayers.find(p => p.id === playerId); } if (!player) { console.error(`Save Player Changes: Player with ID ${playerId} not found.`); alert(`Feil: Fant ikke spiller med ID ${playerId} ved lagring.`); closeEditPlayerModal(); return; } const newName = nameInput.value.trim(); const newRebuys = parseInt(rebuysInput.value); const newAddon = addonCheckbox.checked; if (!newName) { alert("Navn kan ikke v√¶re tomt."); return; } if (isNaN(newRebuys) || newRebuys < 0) { alert("Ugyldig antall rebuys."); return; } let logMessages = []; let potAdjustment = 0; let rebuyCountAdjustment = 0; let addonCountAdjustment = 0; const oldName = player.name; const oldRebuys = player.rebuys || 0; const oldAddon = player.addon || false; if (newName !== oldName) { logMessages.push(`Navn endret fra "${oldName}" til "${newName}".`); player.name = newName; } if (newRebuys !== oldRebuys) { const rebuyDiff = newRebuys - oldRebuys; rebuyCountAdjustment = rebuyDiff; potAdjustment += rebuyDiff * (state.config.rebuyCost || 0); player.rebuys = newRebuys; logMessages.push(`Rebuys justert fra ${oldRebuys} til ${newRebuys} (${rebuyDiff > 0 ? '+' : ''}${rebuyDiff}).`); } if (newAddon !== oldAddon) { if (newAddon) { addonCountAdjustment = 1; potAdjustment += state.config.addonCost || 0; logMessages.push(`Add-on manuelt lagt til.`); } else { addonCountAdjustment = -1; potAdjustment -= state.config.addonCost || 0; logMessages.push(`Add-on manuelt fjernet.`); } player.addon = newAddon; } if (logMessages.length > 0) { state.live.totalRebuys = (state.live.totalRebuys || 0) + rebuyCountAdjustment; state.live.totalAddons = (state.live.totalAddons || 0) + addonCountAdjustment; state.live.totalPot = (state.live.totalPot || 0) + potAdjustment; const fullLogMsg = `Manuell justering for ${newName}: ${logMessages.join(' ')} Pott justert med ${potAdjustment} kr.`; logActivity(state.live.activityLog, fullLogMsg); console.log(fullLogMsg); updateUI(); saveTournamentState(currentTournamentId, state); } else { console.log("Ingen endringer √• lagre for spiller."); } closeEditPlayerModal(); }
    // === 12: EVENT HANDLERS - MODAL & EDIT SETTINGS END ===

    // === 13: TOURNAMENT FINISH LOGIC START ===
    async function finishTournament() { if (state.live.status === 'finished') return; console.log("Finishing T..."); logActivity(state.live.activityLog,"Turnering fullf√∏res."); playSound('TOURNAMENT_END'); if(timerInterval)clearInterval(timerInterval);timerInterval=null; if(realTimeInterval)clearInterval(realTimeInterval);realTimeInterval=null; state.live.status='finished'; state.live.isOnBreak=false; state.live.timeRemainingInLevel=0; state.live.timeRemainingInBreak=0; if(state.live.players.length===1){const w=state.live.players[0];w.place=1;state.live.eliminatedPlayers.push(w);state.live.players.splice(0,1);logActivity(state.live.activityLog,`Vinner: ${w.name}!`);}else if(state.live.players.length>1){logActivity(state.live.activityLog,`Fullf√∏rt med ${state.live.players.length} spillere igjen.`); state.live.players.forEach(p=>{p.eliminated=true;p.place=null;state.live.eliminatedPlayers.push(p);}); state.live.players=[];}else{logActivity(state.live.activityLog,`Fullf√∏rt uten aktive spillere.`);} state.live.eliminatedPlayers.sort((a,b)=>(a.place??Infinity)-(b.place??Infinity)); updateUI(); saveTournamentState(currentTournamentId,state); alert("Turneringen er fullf√∏rt!"); }
    // === 13: TOURNAMENT FINISH LOGIC END ===

    // === 14: EVENT LISTENER ATTACHMENT (General) START ===
    // FJERN addClickListener her - listeners legges til i open...Modal funksjoner
    // function addClickListener(element, handler, handlerName = 'anonymous') { /* ... */ }

    // Listeners for Hoved-UI (legges til √©n gang ved last)
    startPauseButton?.addEventListener('click', handleStartPause);
    prevLevelButton?.addEventListener('click', () => handleAdjustLevel(-1));
    nextLevelButton?.addEventListener('click', () => handleAdjustLevel(1));
    adjustTimeMinusButton?.addEventListener('click', () => handleAdjustTime(-60));
    adjustTimePlusButton?.addEventListener('click', () => handleAdjustTime(60));
    lateRegButton?.addEventListener('click', handleLateRegClick);
    endTournamentButton?.addEventListener('click', handleEndTournament);
    btnForceSave?.addEventListener('click', handleForceSave);
    btnBackToMainLive?.addEventListener('click', handleBackToMain);
    btnToggleSound?.addEventListener('click', () => { console.log("btnToggleSound clicked."); soundsEnabled = !soundsEnabled; saveSoundPreference(soundsEnabled); updateSoundToggleVisuals(); logActivity(state.live.activityLog, `Lyd ${soundsEnabled ? 'P√Ö' : 'AV'}.`); });
    btnEditTournamentSettings?.addEventListener('click', openTournamentModal);
    btnEditUiSettings?.addEventListener('click', openUiModal);
    btnManageAddons?.addEventListener('click', openAddonModal);

    // Drag & Drop
    draggableElements.forEach(el => { if (el) { el.addEventListener('mousedown', (e) => startDrag(e, el)); } });

    // Klikk utenfor modal
    window.addEventListener('click', (e) => { if (isModalOpen && currentOpenModal && e.target === currentOpenModal) { console.log("Clicked outside modal content."); if (currentOpenModal === uiSettingsModal) { closeUiModal(true); } else if (currentOpenModal === tournamentSettingsModal) { closeTournamentModal(); } else if (currentOpenModal === addonModal) { closeAddonModal(); } else if (currentOpenModal === editPlayerModal) { closeEditPlayerModal(); } } });
    // === 14: EVENT LISTENER ATTACHMENT (General) END ===

    // === 15: INITIAL UI RENDER & TIMER START ===
    console.log("Performing final setup steps...");
    try {
        updateUI(); startRealTimeClock();
        if (state.live.status === 'running') { console.log("State is 'running', starting timer."); if (timerInterval) clearInterval(timerInterval); timerInterval = setInterval(tick, 1000); }
        else if (state.live.status === 'finished') { console.log("State is 'finished'."); }
        else { console.log(`State is '${state.live.status}'. Timer not started.`); if (timerInterval) clearInterval(timerInterval); timerInterval = null; }
        console.log("Tournament page fully initialized and ready.");
    } catch (err) { console.error("Error during final setup or UI update:", err); alert("En feil oppstod under lasting av siden. Sjekk konsollen."); }
    // === 15: INITIAL UI RENDER & TIMER START ===

});
// === 01: DOMContentLoaded LISTENER END ===
